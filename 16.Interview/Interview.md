# JDK

*接口和抽象类的区别 :*

- 访问修饰符   抽象类具有四种访问修饰符    接口仅仅具有public
- 方法的定义   抽象类可以定义各种方法       接口仅有抽象方法
- 职责   抽象类是代码的复用  接口为制定规范  (模版方法模式)
- 单继承  多实现 

*RPC接口返回中,使用包装类型的原因 :*

- 比如某个字段表示费率Float rate,在接口返回时,如果出现异常可能返回默认值,float返回为0.0  Float类型返回是null
- 在接口中为了避免发生歧义,建议使用对象,因为他的默认值是null 出现null的时候,我们明确知道他是出错的 但是看到0.0的时候,无法确定是否真的出错;

*泛型的优缺点 :* 泛型是JDK5提供的一种新的特性,允许在定义类和接口的时候使用参数类型;声明的类型参数在使用时具体的类型来替换

- 提高代码的复用性;比如以List接口为例,将String Integer等类型放入到List中.不使用泛型,存放String类型要写一个List接口
- 安全性: 在泛型出现之前,类型转换之前需要运行时检查,类型出错程序注解GG 泛型会在编译时做类型的检查,无疑增加程序的安全性
- Java中的泛型通过类型擦除的方式实现, Java的泛型只存在编译期,Jvm是不会感知到泛型的

*反射机制 :*

- Java在运行时通过类的名称能够获取自身的信息;通过反射机制获取成员属性和方法 创建类的对象并调用这些方法
- 但是在业务代码减少反射机制的使用
  - 反射机制涉及动态解析的类型,不能执行某些Java虚拟机优化
  - 使用反射机制,参数需要包装成Object[] 类型,真正执行的时候,需要进一步的拆包成真正的类型,这一过程不仅消耗时间还会产生很多对象,对象一多就容易导致GC
  - 反射调用方法时会从数组中遍历查找,并且会检查可见性,动作都是耗费时间的 同时参数也需要进行额外的检查
- 动态代理  ORM框架  Mybatis框架    Spring框架的IOC/DI注入  JDBC的class.forName方法

*动态代理机制  :*

- JDK动态代理 通过Java.lang.reflect包中的 Proxy类和InvocationHandler接口提供了生成动态代理类的能力
  - 动态代理的对象需要一个或者多个接口
- CGLib动态代理 第三方代码生成库,运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展
  - 运行时期可扩展Java类和实现Java接口,且无需实现接口 通过继承的方式实现对目标对象功能的扩展,达到代理类无侵入

*注解 :*

- Java中的注解为Java代码提供了元数据.注解不会影响代码的执行 它可以说为一种标识,标识类或者一个字段
- 常用于 : 反射 AOP结合起来使用   自定义注解 + AOP 实现记录日志操作     自定义注解 + 参数校验工具类 + AOP实现参数的校验

*浅拷贝和深拷贝的区别 :*

- 浅拷贝 仅仅复制对象的地址,而不是对象的本身;也就是说,原始对象和复制对象实际上共享同一个内存地址
- 深拷贝  将会重现创建一个对象,将一个对象的所有基本属性和子对象拷贝到另一个对象中;
  - 实现Cloneable接口,重写Clone()方法
  - 序列化实现深拷贝 先把对象序列化成流,再从流中反序列化成对象,这样就一定为新对象

*String字符串不可变原因 :*

- String类被final修饰 无法被继承,方法不会被覆盖
- final 修饰字符串内容的char[] 一但被初始化无法修改
- String类没有提供用于修改的字符串内容的公共方法;



*Java中的定时调度器 Timer :* 用于在指定的时间点执行任务

- TaskQueue: 任务队列,用于存储已经计划的定时任务;任务队列按照任务的执行时间进行排序,确保最早执行的任务排在队伍前面
- TimerThread: Timer内部的后台线程,他负责扫描 TaskQueue 中的任务,检查任务的执行时间,然后在执行时间到达时执行任务run()方法,TimerThread是一个守护线程,因此所有非守护线程完成时,它就会终止;

# Collection

![image-20240319155650953](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240319155650953.png) 

*ArrayList 底层原理 :*  有序可重复数据,线程不安全    可以存放为NULL的数据

- ArrayList通过动态数组进行实现的 
- 不指定集合容量,默认为10  指定集合容量根据指定容量
- ArrayList每次添加数据都会 通过size + 1 去比较容量,不满足容量将会进行1.5被扩容 

*LinkedList 底层原理 :* 有序可重复数据,线程不安全

- LinkedList通过双向链表进行实现
- 并且标记头尾指针 每个位置存储 前置和后置指针+存储的数据

*ArrayList 和 LinkedList的区别 :*

- 底层存储的数据结构不同
- 占据的空间不同
  - ArrayList 占据连续的内存空间,内存相较于占据较少
  - LinkedList 占据非连续的空间,且存储 前后指针 + 数据 内存占据相较于较大
- 效率
  - ArrayList 对于通过索引进行查询效率较高 O(1)  非索查询效率 O(n)
  - LinkedList 查询头尾数据为O(1)  其余查询效率为O(n)
  - ArrayList插入和删除数据 除尾部进行效率O(1) 其余全为 O(n)
  - LinkedList 插入和删除数据 头部和尾部效率O(1)  其余全为O(n)
- 线程安全
  - 都是线程不安全的  方法内部使用,定义为局部变量  /  通过使用Collections.synchronizedList()方法创建



*HashMap 的底层原理 :*  底层原理为 Hash表数据结构 即数组和链表或红黑树(防止恶意攻击)  负载因子为0.75

- 当向HashMap中put元素时,利用key的hashCode计算的数据%数组的容量计算出当前对象的元素在数组中的下标
- 存储时,出现hash值相同的key,此时具有两种情况
  - key值相同,则覆盖原始值
  - key值不同(出现冲突),则将当前的key-value放入链表或红黑树中
- 当链表的长度大于8且数组长度大于 64时将转换为红黑树 当链表的长度小于6的时候,红黑树将会退化成单链表;
- 扩容阈值 = 数组容量 * 负载因子  默认数组容量 16

*HashMap 的put实现 :*

- 根据键值对数组table判断是否为空,否则进行初始化 初始化容量为16  负载因子为0.75
- 根据键值key计算hash值 对数组容量取模计算出索引值
- 判断数组的当前索引是否存在节点,不存在直接添加
- 当前数组的索引存在索引判断三种条件
  - 首元素是否和key值一样  直接覆盖
  - 判断是否为红黑树 红黑树直接添加
  - 如果为链表则进行循环在尾部添加,判断链表长度是否大于8,大于8将链表转换为红黑树
- 插入成功,判断实际容量是否超过阈值(容量值 * 负载因子)

*HashMap 的扩容机制 :*

![image-20240319175042427](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240319175042427.png) 

*HashMap的寻址算法 :*

![image-20240319175825274](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240319175825274.png) 

# SSM

*Spring MVC的执行流程 :*

- 客户端发送请求给前端控制器接收
- 前台控制器发送请求给处理器映射器 查询handler
- 返回处理器执行链,可能包含处理器拦截器
- 前端控制器向处理器适配器发送,请求执行的handler
- 找到匹配的处理器 进行参数的处理 返回值的处理  Model and View
- 前端控制器将Model and view 发送给视图解析器 返回View对象
- 渲染视图

![image-20240318204210786](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240318204210786.png)

![image-20240318204449727](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240318204449727.png)  

*Spring的IOC和AOP :*

- 控制反转是一种设计模式,用于减少计算机程序中各个模块之间的依赖关系,我们只需要定义一个Bean的创建过程,而真正的创建 初始化 装配 生命周期都是通过容器进行管理; Spring通过依赖注入对象,我们只需要关心核心逻辑即可;
- IOC 完全符合 DIP ,高模块不直接依赖低模块,而是依赖低模块的抽象 低模块去实现抽象
- 底层原理的实现: 工厂方法设计模式



- AOP 面向切面编程   在不修改源代码的情况下,抽取并封装一个可重用的模块,可以同时作用于多个方法,减少模块耦合的同时,扩展业务功能;
- 可用于日志记录 事务处理 解决缓存
- 底层原理的实现: 动态代理模式  (JDK 根据接口进行实现    CGLIB两种框架通过继承进行实现)

*Spring的生命周期 :*

- 通过BeanDefinitionReader解析xml配置文件
- BeanDefinition获取bean的定义信息
- 调用构造函数实例化bean
- bean的依赖注入
- 处理Aware接口 (BeanNameAware BeanFactoryAware ApplicationContextAware) 获取bean对象名称 工厂等
- Bean的后置处理器BeanPostProcessor-前置
- 初始化方法(自定义的init方法)
- Bean的后置处理器后置BeanPostProcessor-后置 
- 使用Bean
- 销毁bean

![image-20240318203357738](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240318203357738.png) 

*Spring的三级缓存解决循环依赖问题 :*

1. 实例化对象A  原始对象A生成ObjectFactory对象存放在 singletonFactories
2. 需要注入对象B
3. 实例化对象B  将原始对象B生成ObjectFactory对象存放在 singletonFactories
4. 需要注入A 从三级缓存中获取A的ObjectFactory对象,创建代理对象存放到二级缓存中
5. 将A的代理对象注入给B 
6. B创建成功 加入到三级缓存中
7. 将B注入给A  
8. A创建成功 加入到三级缓存中

![image-20240318203619074](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240318203619074.png)  

*Mybatis的执行流程 :*

- 读取Mybatis配置文件: 通过配置文件加载运行环境和映射文件

![image-20240318205507477](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240318205507477.png) 

*Mybatis的缓存机制 :*



*SpringBoot的自动装配 :*

- @SpringBootApplication注解是三个注解的封装
- @SpringBootConfiguration 和 @Configuration注解相识声明当期为配置类
- @ComponentScan 注解扫描当前包以及子包
- @EnableAutoConfiguration 实现自动化配置的核心注解,该注解通过@Import注解导入对应的配置器选择器;内部读取了此项目和该项目引入的jar包类路径下META-INF/spring.factories文件中的所有配置类的全类名; 这些配置类中所定义的Bean会根据条件注解所指定的条件来决定是否导入Spring容器中

# Mysql

*事务的特性以及隔离级别 :*

事务为操作的序列,不可进行分割的工作单位 执行的这些操作要么同时成功,要么同时失败.

ACID  

- Atomicity(原子性)事务不可再分割的工作单元,要么同时成功要么同时失败
- Consistency(一致性) 事务执行前后,数据的完整性不会被破坏
- Isolation(隔离性) 事务之间存在隔离级别,防止多个事务之前的互相干扰
  - 读未提交  RU    可能会出现脏读问题  --> A事务执行Insert,未commit  但是B事务读取到了A事务的Inset;
  - 读提交 RC       不会出现脏读,但会出现不可重复读问题 --> A事务第一次读取一条记录和第二次读取同一条记录内容不同(针对Update) B事务在A事务第二次读取这条记录时,进行了修改操作
  - 可重复度 RR    不会出现脏读 可重复读的问题 但会出现幻读问题 --> A事务第一次查询条件读取到3条记录,第二次根据相同的查询结果读取到了2条记录  B事务在A事务第二次条件查询的时候,对表中的数据进行了Delete操作  导致了幻读
    - 解决幻读的方法  有两种  快照读 / 当前读
  - 串行化  不允许多个事务并发访问
- Durability(持久性) 事务一但提交或回滚对于数据库的操作是永久性的

*快照读和当前读解决幻读问题 :*

- 快照读是普通Select查询语句的默认行为.通过MVCC来避免幻读问题
- 事务启动时,第一个查询语句执行后,会创建ReadView 后续使用的查询语句使用这个ReadView,从事务开始时的数据版本链中获取数据
- 因此整个事务中,每次查询的语句都保持一致,即使其他事务中途进行插入了新记录,也不会影响当前事务的查询结果;



- 当前读 当执行 DML 语句 和 Select ... For Update等语句,这些操作会查询到当前版本的最新数据,然后再进行下一步操作;
- 当执行Select ... For Update 操作时,条件查询到的结果集 会通过间隙锁将其锁住; 其他事务无法对锁住的结果进行插入和修改操作;

*解析MVCC的工作流程 :* MVCC并发控制机制,他通过为每个读操作创建一个视图来实现读写分离,保证多个事务同时读写同一个数据时的一致性和并发性

----

*索引的应用场景 :*  索引是一种数据结构 B+树的数据结构,用于提高数据库的查询效率;

- 对于数据量较大,且查询比较频繁的表建立索引;
- 常用于条件查询 排序 分组操作的字段创建索引;
- 不经常对于表中的数据进行修改操作的数据表创建索引,因为每次修改都需要重新创建索引的数据结构,会大幅度降低性能;

*聚簇索引和非聚簇索引 :*   回表   减少回表的操作 --> 覆盖索引

- 聚簇索引一般为表的主键,没有表的组件将会用唯一字段代替 如果都没有InnoDB将会自动生成一个rowId作为隐藏的聚簇索引
- 聚簇索引将索引和数一起存储,据根据索引字段进行排序,并将完整的数据存放到叶子节点上



- 非聚簇索引,将索引和数据分开存储 叶子结点上存储的数据为对应的主键;
- 根据查询的数据,判断是否需要,通过获得的主键进行回表操作

*覆盖索引 :*

- 通过索引进行条件查询,返回的数据在索引中可以获取,无需进行回表的操作;

*最左前缀原则 :*

- 创建组合索引的顺序为 (A,B,C)  需要保证索引的正常使用,在查询条件时的字段A需要位于索引的最左则



*索引失效情况 :*

- 索引字段参见运算操作,原因为参加运算操作的字段数据类型发生改变导致索引失效
- 字符串类型的字段没有添加'',字段的数据类型发生改变导致索引失效
- 进行模糊查询时 %位于最左侧,当前创建索引的字段无法进行排序比较,索引失效
- 违背了最左前缀原则

----

*sql优化策略 :*

- 表的设计优化
  - 设置合适的数值(tinyint int bigint)
  - 设置合适的字符串类型 char 和 varchar,char的效率比较高 varchar效率稍低 
- 索引的优化  (遵守最左前缀原则 覆盖索引 使用联合索引 创建索引的字段具有唯一性)
- Sql语句优化
  - Select语句务必指定字段的名称
  - DQL语句避免索引失效的写法
  - 多表连接的优化,在业务场景允许的情况下 最好使用内连接 而不是外连接,如果使用尽量使用小表为驱动,内连接会对两个表进行优化,优先把小表放到外面,大表放到里面;小表放在外面可以减少回表的次数,大表减少过滤的数据量; 
- 主从复制 读写分离
  - 数据库读取数据的操作较多时,可以采用读写分离的架构;读写分离解决了数据库的写入影响查询效率;
    - 基于binlog实现同步,主库产生的binlog日志记录了所有的写操作,从表通过binlog日志实现同步
    - 延迟消费 避免从库获取到未同步的数据,可以设置一个延迟的时间等待一段时间后再进行数据的处理
    - 监控系统,实时监控主从库的同步状态
- 分库分表
  - 水平分库,将一个库的数据拆分到多个库中,解决海量数据存储和高并发的问题   访问需要通过 myCat(中间件进行实现)
  - 水平分表,解决单表存储和性能的问题
  - 垂直分库 根据业务进行拆分,高并发下提高磁盘IO和网络连接数
  - 垂直分表 冷热数据隔离,多表互相不影响

# Redis

*常用数据类型 :*  实际开发使用过 String类型 和 Hash类型 展开讲讲

- String类型   --> 字符串类型为最常用的类型  一般存储验证码 或者 短信验证码 或者 用户的id等  规则一般为 项目名称:业务名:UID + value
- List类型  底层为双端队列  
- Hash类型 底层为Hash表 --> key value 形式  value里面存放的为另一个key value 实际项目中我key存放商品的分类信息  value里面key存放商品id value就是值
- Set类型  
- ZSet类型 有序集合类型

*持久化的方式 :*  两种持久化的方式  RDB AOF 

- RDB
  - 将Redis内存的数据产生一个快照,满足一些条件自动保存在磁盘上,防止数据在Redis进程异常退出或服务器断电的情况下丢失;
  - 定期更新的策略默认的有 1小时修改一次就会进行保存  5分钟修改100次就会触发自动保存  还可以通过 save 或 bgsave手动更新
  - 不推荐使用 save 因为他可能会出现阻塞的问题  bigsave就不会出现线程阻塞的问题,因为他的主线程会fork出一个新的分支 来进行更新操作
  - 主从复制,主节点自动触发
  - flushdb / flushall 命令会产生dump.rdb文件 但也会将命令记录到 dump.rdb文件中
- AOF  需手动开启AOF
  - 以记录日志的形式,将redis进行的操作写入文件中,无法进行修改操作 只能进行添加操作
  - 执行流程为 用户发送redis命令 交给redis redis将进行的操作写入到AOF缓存中,通过AOF缓存再写入磁盘AOF文件,AOF文件的增加会触发重写机制进行压缩文件
  - AOF三种写回策略
    - Always 同步写回: 写指令执行完毕,里面同步到磁盘中
    - Everysec 每秒写回: 每个写命令执行完毕,先放入到AOF缓冲区,每个一秒将缓冲区的数据进行写入
    - NO 操作系统控制写回  随机性太大了
- RDB + AOF  
  - 开启混合持久化,AOF重写时会把Redis中的持久化数据,以RDB的格式写入到AOF文件中,之后的数据以AOF的格式追加到文件末尾
  - 以RDB的格式开头,使Redis更快启动,同时结合AOF的优点,减少大量数据的丢失风险

*主从复制的执行流程 :*

- 从机连接到主机会发送同步请求
- 首次连接的从机会进行全面更新,从机原有的数据会被覆盖
- 主机接收到从机的同步请求会在后台保存快照,同时将接受的所有修改指令缓存起来,执行完RDB持久还后,将RDB快照文件和缓存命令发送给从机完成同步
- 从机会每10s向主机发送心跳,确保从机还在
- 主机会将修改的命令自动发送给从机,完成同步
- 从机下线,在上线  主机和从机都会保存一个offset(表示主机向从机传递命令的总字节数)和一个主机ID,offset保存在backlog
- 主节点需要将数据复制给从节点时,可以根据backlog的offset,将从机未具有的数据进行复制;

![image-20240320205723412](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240320205723412.png) 

*哨兵节点的选举方式 :*

- 主观下线   一个哨兵会定期检查一个节点,当发现某个节点 超过规定时间内,未进行返回信息,当前哨兵认为此节点宕机;这是主观下线.  
- 客观下线    这时其他哨兵也会来检测此节点,当哨兵达成一致意见时,就会确认该节点已经宕机 若是主节点将会进行选举新的节点

![image-20240320162612743](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240320162612743.png) 

*缓存出现的问题有哪些 :*

- 缓存穿透    查询一个不存在的数据,redis找不到 mysql也找不到,这样数据不会存放在redis中 每次请求都查询数据库

  - 缓存空值

    - 可以将这些key对应的值设置为null并方到缓存中,这样在出现查询这个key的请求时,直接返回

  - 布隆过滤器    一种数据结构,用于快速检索一个元素是否可能存在于一个集合中(bit 数组)  首先将热点数据进行预热加入到布隆过滤器中

    - 它的基本原理是利用多个hash函数,将一个元素映射成多位,然后将这些位设置为1;查询某个元素时,如果这些位置
    - 设置为1,则认为该元素可能存在集合中,否则肯定不存在

    ![image-20240320165730060](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240320165730060.png) 

- 缓存击穿  当某个key值缓存过期了同时出现大量请求去访问此key值,瞬间击穿服务器直接访问数据库,数据库处于负载的情况
  - 异步定时更新
    - 比如一个热点数据的过期时间为1个小时,那我们就每59分钟,定时任务去更新这个热点key,并重新设置过期时间
  - 互斥锁
    - Redis中根据key获取到的值为null时,先进行上锁然后从数据库加载,加载完毕后释放锁;若其他线程也请求key时,发现获取锁失败,则进行阻塞
- 缓存雪崩  大量缓存同时过期,或缓存宕机,所有请求去直接访问数据库,造成数据库高负载,影响性能,甚至数据库宕机
  - 不同的过期时间
    - 为了避免大量的缓存同一时间过期,可以把不同的key过期时间设置为不同的,并通过定时刷新的方式更新过期时间
  - 集群
    - 集群的搭建可以有效的避免服务器单点故障出现雪崩问题;

*过期策略 :* Redis的过期策略具有两种  

- 定期删除
  - Redis默认每个100ms就随机取一些设置的key,并检查是否过期,如果过期就删除;
- 惰性删除
  - 当一个key过期时,不会立即在内存中删除,而是在访问这个key的时候才会触发删除操作 Redis的被动删除策略

*Redis和数据库的一致性问题 :*

- 优先考虑删除缓存而不是更新缓存,删除缓存更加简单,而且带来一致性的问题也会更少

- 要执行延迟双删的策略

  - 删除缓存     可能会出现 缓存击穿  通过加锁的方式防止
  - 更新数据库
  - 再次删除缓存  避免并发出现的脏数据

  为了提高稳定性和降低对代码的侵入性,考虑把缓存的删除(更新) 做成异步化,通过MQ或者监听数据库的binlog方式来进行处理

![image-20240320185812124](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240320185812124.png)

*数据的淘汰策略 :*	

![image-20240320203634599](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240320203634599.png) 

*集群模式 :*

![image-20240320210328881](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240320210328881.png) 



# RabbitMQ

- 熟悉消息队列的应用场景，理解RabbitMQ确保消息可靠性的机制、消息确认的机制

*消息队列的常用应用场景 :*

- 异步执行
- 解耦: 每个服务都可以灵活插拔,不可替换 
- 流量削峰: 不管发布事件的流量波动多大,都通过Broker接收,订阅者可以按照自己的速度去处理事件

*RabbitMQ保证消息可靠的机制 :*

- 发布者发送消息给 Broker的交换机,交换机会自动返回Callback,来确定这条消息是否正确的发送到Broker的交换机中,确保消息的可靠性
- 交换机接收消息后会根据 路由键 发送给绑定的队列,发送成功没有任何操作 失败后会发送应答 退回机制
- 设置交换机 队列 消息的持久化
- 默认情况下消费者接收到消息后自动确认删除消息,将自动删除更改为手动确认消息,业务出现异常可不确认消息,重新进行投放或放入死信交换机中;

*RabbitMQ如何实现延迟消息 :*

- 死信交换机(被拒接的消息 无法消费的消息 过期的消息 消息队列已满的消息) + 设置消息过期时间 
  - 可能会造成对头阻塞,因为队列是先进先出每次只会判断对头消息是否过期,那么对头消息时间过长一直不过期,那么就会阻塞整个队列
- 通过插件进行实现
  - 消息不回立即进入到队列,而是现将他们保存基于Erlang开发的Mnesia数据库中,然后通过定时器去查询需要投递的消息,再把他们投递到死信交换机中
  - 最大的支持时间为 2^32 -1毫秒 大约49天,超过这个时间会被立即消费掉.

*如何防止RabbitMQ的重复消费 :*  一锁 二判 三更新  幂等性(同一操作的多次执行所产生的结果与单次执行的结果相同)

- RabbitMQ消费消息具有确认机制,默认情况下 消费者在投递消息成功后,会发送一个确认机制,消息队列接收到之后,就会将消息从队列中删除
- 可能出现网络波动的情况下,导致确认消息没有及时发送到消息队列,导致消息重投了,是有可能的 所以我们使用MQ的时候,消费者要做好幂等性的处理
- 通过每一个消息设置一个唯一性的id  判断当前id在redis中是否存在 存在则说明此消息已经消费过了  不存在说明消息还没消费,消费完 id存放在redis中;

# Spring Cloud Alibaba

## Nacos

Nacos是阿里巴巴开源的服务注册中心和配置中心,并提供了可视化的配置管理工具

![image-20240322163352560](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240322163352560.png) 

*Nacos的执行流程 :*

1.  将服务提供者进行 注册服务信息
2. 定时拉取服务的消费者
3. nacos主动查询服务提供者的心跳
4. 服务提供者变更时,主动推送变更的消息



- Nacos支持服务端主动检测提供者状态: 临时实例采用心跳模式(AP 高可用) 非临时模式采用主动检测模式(CP 强一致)
- 临时实例心跳不正常会被剔除 非临时实例则不会被剔除
- Nacos支持服务列表变更的消息推送模式,服务列表更新更及时

## Gateway

*实现负载均衡 :*

- 网关会与微服务注册中心进行通信,获取注册在注册中心的所有服务以及对应的信息
- 选择合适的负载均衡策略,
  - 轮询  依次将请求分配给后端的不同实例,按照顺序轮流分配
  - 加权轮询 根据后端服务的权重,决定分配请求的比例
  - 随机    随机选择一个服务
  - 最小链接 选择当前请求最少的后端服务
  - 哈希 根据某些属性计算哈希值,将相同哈希值的请求到路由到同一个后端服务实例