# 讲讲你对集合的理解

答 :  集合在开发中是必不可少, 从整个集合的类型上分为 单列集合 和 多列集合

单列集合为   Collection 接口下, 具有 List接口 和 Set接口 

List 接口 下分为  ArrayList  LinkedList   Vector;   ArrayList 和 LInkedList为线程不安全  Vector为线程安全

ArrayList底层为 数组   LinkedList底层为 链表    

**而且在项目中我经常使用 ArrayList** 

- 主要是 ArrayList随机访问效率较高, 可以通过索引直接进行访问 时间复杂度为 O(1), LinkedList访问需要从头进行顺序访问, 时间复杂程度为O(n)
- ArrayList通过数组存储元素每个元素占有固定的内存空间, LinkedList内部通过链表存储元素 ,除了存储当前元素值还需要存放指向下一个节点的指针, 因此ArrayList的占据的内存空间小于LinkedList占据的内存空间.
- 尽管LinkedList插入和删除具有一定的优势, 但是大部分实际项目中 随机访问效率和内存占用通常更为重要, 所以我较为倾向ArrayList, 只有在频繁进行插入和删除操作, 并且对随机访问要求不高的 内存占据不高, 才会考虑LinkedList.

ArrayList存在解决线程安全问题, 通过将ArrayList设置为局部变量 /  Collections.synchronizedList() / 并发工具包提供的线程安全集合 CopyOnWriteArrayList

CopyOnWriteArrayList如何实现线程安全:  实现了读写分离, 读操作可以并发执行, 写操作是串行化的 导致内存的消耗

- 在修改 删除 添加操作前, 会先复制当前数组内容到新的数组中
- 执行修改操作, 对复制的数组执行修改操作
- 替换原数组, 完成修改后, 用新的数组替换原来的数组  替换的过程中保证原子性  volatile  +  CAS



双列集合为 : Map接口, 具有HashMap 线程不安全  HashTable 线程安全 锁的是整个 哈希表

HashMap 和 HashTable的底层数据结构为 哈希表  数组 + 链表 / 红黑树

JDK7时 HashMap 的哈希表组成为  数组 + 链表

JDK8时 HashMap 的哈希表组成为  数组 + 链表 / 红黑树  当数组(桶)的容量大于64 而且链表的长度为8的时候, 将会从链表变成红黑树

链表变为红黑树的主要原因为 避免恶意攻击导致, 某个桶下的hash冲突较为严重, 链表长度无限加长 查询效率极大的降低 而红黑树为自平衡二叉树, 查询的时间复杂度为 O(log n) 当n的数量越大, 查询的复杂度越为平稳.

HashMap添加数据的步骤: 

- 根据 hashCode() 方法计算键的哈希值
- 将哈希值无符号 >>> 16位, 将高位的信息混合到低位中, 增加了哈希函数的散列性, 减少了哈希冲突的概率.  扰动函数算法
- 通过 与运算 计算索引的位置, 主要原因为 集合的容量为 2的幂次方  哈希值对2^n - 1进行与运算 低位进行保留, 高位会被置为 0 实现快速的确定索引位置
- 比如: 集合容量为 16 二进制表示为 10000 减1得到 01111, 对哈希值进行与运算时, 只有低4位进行保留, 高位都为0 快速实现映射 

**项目中的应用场景**  缓存管理 	配置管理(工厂模式(单例模式) + 配置文件 )    ConcurrentHashMap 管理Bean对象的元数据, 名称 类名 依赖关系



ConcurrentHashMap 线程安全

JDK7时 ConcurrentHashMap  通过  Segment (分段锁)  数组  + Reatenlock    每个分段锁代表一个独立的哈希表, 不同的线程可以访问不同的Segment, 减少锁的竞争

JDK8时 ConcurrentHahsMap  哈希表被分割为多个桶,  每个桶上使用 CAS操作 和 synchronized 来保证线程安全 

- 当进行 插入 删除或者更新操作时, CAs操作成功说明没有其他线程同时进行修改,  
- 操作失败, ConcurrentHashMap 会使用 synchronized 关键字来进行同步, 每个桶都会设置一个独立的锁, 不同桶之间可以并发进行.



# 了解过线程池吗

答 : 线程池是一种池化技术, 降低资源的消耗  提高相应的速度  统一管理和监控 

- 降低资源的消耗  -->  创建线程和销毁线程开销较大, 使用线程池可以复用已经创建的线程, 减少线程的创建和销毁的次数  降低系统资源的消耗
- 提高相应速度 -->  任务到达, 线程池中存在线程可以立即执行任务 无需等待线程的创建
- 统一管理和监控 --> 线程池可以统一管理和监控线程的状态 执行情况 便于监控和调试
- 限制并发任务的数量, 防止服务被压垮, 同时可以提高系统的稳定性和可靠性.

线程池中具有 6个 重要的参数

- 核心线程数目
  - 根据当前执行的任务确定, 选择合适的核心线程数目    
  - I/O密集型: DB读取 文件的读取 网络请求   2N + 1
  - CPU密集型 : 计算型代码 BitMap 转换   N + 1       
- 最大线程数目   空闲存活时间   存活时间的时间单位  
- 阻塞队列   
  -  LinkedBlockingQueue 默认无界, 支持有界 底层为链表 且为懒加载的模式 而且会生成新的Node, 头尾各有一把锁
  - ArrayBlockingQueue 强制有界, 底层为数组, 初始化创建Node数组 存在一把锁
- 线程工厂(指定线程的名称 是否为守护线程等) 
- 拒绝策略
  - 默认直接抛出异常
  - 将加入的任务直接抛弃
  - 调用者所在线程来执行任务
  - 丢弃阻塞队列中最靠前的任务, 放入当前任务

**线程池的应用场景 :**

- 异步任务的处理, 异步任务的处理过程中, 通常需要创建大量的任务, 并发执行这些任务. 使用线程池可以管理和控制任务的执行, 限制并发任务的数量,提高系统的稳定性, 同时可以利用线程池的重用机制, 减少任务的开销.   向日志的统一记录 存入到数据库中,通过异步执行 使用线程池来完成



**禁止使用Executors指定线程池 :**

- 线程池的参数不可控制, newFixedThreadPool 方法创建固定大小的线程池, 且阻塞队列为无限队列   可缓存线程池 基本无界的核心线程数目
- 线程池任务的拒绝策略不合适, 默认使用抛出异常的拒绝策略

# 使用过ThreadLocal吗

答 :  ThreadLocal存储线程的局部变量, 线程之间相互隔离互补干扰.

JDK7 时 ThradLocal的设计原理 :

 ![image-20240329203825694](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240329203825694.png)

- ThreadLocal创建一个ThreadLocalMap.
- Thread作为ThreadLocalMap的key,存储的局部变量作为value, 达到线程隔离的作用.

JDK8 时 ThradLocal的实际原理 :

![image-20240329204035410](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240329204035410.png) 

- 每个线程内部都有一个Map(ThreadLocalMap).

- Map里面存储的ThreadLocal对象(key)和线程变量副本(Value)也就是存储的值.

- Thread内部的Map是由ThreadLocal维护的, 有ThreadLocal负责向map获取和设置线程变量值.

- 对于不同的线程, 每次获取value(也就是副本值),别的线程并不能获取当前线程的副本值, 形成了副本的隔离,互不干扰.

JDK8优化之后的好处 :  减少了哈希冲突 JDK8中通过使用线性探测的方式来解决哈希冲突, 减少链表的长度, 提高查询的效率. 减少内存泄露的可能, Entry对象使用弱引用的方式指向, ThreadLcoal实例, 一旦ThreadLocal实例被垃圾回收, 对应的Entry对象就会被自动清除, 减少内存泄露的可能.

**Threadlocal的应用场景 :**

- 用户信息的传递, 用户登录成功后需要在多个组件或者层之间进行传递用户的信息, 比如用户的ID 用户的名称, 可以通过ThreadLocal将当前用户身份信息与当前线程关联起来, 在整个请求处理的过程中随时访问用户信息
- 数据库的连接管理, 每个线程需要拥有独立的数据库连接, 确保事务的隔离性和性能; 通过ThreadLocal将数据库的连接对象和当前线程进行关联, 使得每个线程都能连接自己的数据连接, 无需在方法调用中传递连接对象.



# ThreadPool + ThreadLocal 出现的问题

答 : 常见的问题为 内存泄露的问题, 因为 线程池创建的线程, 通常会被复用, 在搭配 ThreadLocal使用时, 需要用户手动去释放ThreadLocal , 当长时间忘记手动释放时, 可能会导致 内存溢出的问题.

面对这个问题最好的解决方案 :   通过动态代理的方式, 在线程执行完毕之后 自动去调用释放 ThreadLocal 避免出现内存溢出的问题

- 创建动态代理类, 实现 InvocationHandler 接口, 在方法调用之前进行一些额外的操作
- 代理类中的invoke方法, 通过反射机制获取目标对象的方法, 在方法执行前后进行 ThreadLocal 数据的清理操作
- 将动态代理和目标对象进行关联, 创建动态代理对象 
- 将动态代理对象交给线程池, 在线程执行任务时使用动态代理对象进行任务执行



# 讲讲 SQL 优化吧 

答 :  SQL优化需要从几个方面进行回到

- 数据库中表的设计
  - 合理设计表的结构, 避免冗余字段和重复数据
  - 选择合适的数据类型和字段长度, 避免浪费存储空间
  - 尽量将大字段存储到独立的表中, 减少主表的数据量  
- SQL语句的规范
  - 避免使用 SELECT * ,  而是明确列出需要的字段, 提高查询性能 代码的维护性
  - 避免在SQL语句中, 使用函数或者运算符运算进行操作, 尽量在应用程序中处理   降低查询的效率 函数计算的过程数据量较大  索引可能会失效
  - 表连接的过程中, 尽量将 小表放在外面 大表放在里面  --> 数据库的查询通常会根据外部表的数据来过滤和筛选内部表的数据, 小表在外可以减少内部表需要处理的数据量
-  索引的优化
  - 根据查询的频率和条件选择合适的字段创建索引
  - 避免过多的索引, 索引过多会增加写操作的开销
  - 通过 覆盖索引  索引下推减少回表的次数
    - 覆盖索引 -->  查询的字段在索引字段中都可以找到减少回表的次数, 多应用在 非聚簇索引上
    - 索引下推 --> 尽早的利用索引字段进行条件查询, 减少回表的次数 
  - 避免索引失效的场景
    - 最左前缀原则  比如 : 非聚簇索引 (复合索引) 存在字段 A , B , C 根据A字段优先建立,索引 之后才是 B C 字段, 所以要保证查询的过程中 A字段存在
    - 索引字段进行运算, 改变了字段的数据类型 索引失效
    - 进行 模糊查询时, %位于第一位, 无法找到适合的匹配结果 索引失效
    - 未使用索引字段进行查询
- 读写分离的实现    -->  redis也存在读写分离的集群  主从模式
  - 将操作和写操作进行分离, 使用主从复制实现读写分离
  - 将读操作负载分散到多个节点上, 提高读取性能
  - 保证 从机 和 主机的数据一致性  通过 binglog日志   从机的 replaylog日志 
- 分库分表
  - 垂直分表  --> 将冷热数据进行分离, 多表之间互不影响
  - 垂直分库 --> 根据业务进行分离, 提高磁盘 I/O
  - 水平分表 --> 解决单表存储和性能的问题 
  - 水平分库 --> 解决海量数据存储和高并发的问题   访问需要通过 myCat(中间件进行实现)



# Redis中常用的数据类型

答 : redis中常用的数据类型分为 :

- String类型
  - 底层的数据结构为 SDS (简单的字符串), 高效的对字符串进行增删改查操作  适合存储简单的键值对数据, 比如: 用户的Token 短信验证码等
- List类型
  - 底层的数据结构为 双向链表, 快速实现插入 删除操作
- Set类型
  - 底层为哈希表 不能存放重复的数据   查询互相关注的UP  通过 SINTER 返回集合之间的交集
- SortSet类型
  - 底层的数据结构为跳跃表和哈希表的组合, 跳跃表为有序的数据结构, 可以实现快速的元素查找和插入,并具有平衡性   有序不重复 --> 点赞排行榜的实现, 根据时间戳进行排序 先点赞的用户排在前面
- Hash类型
  - 底层的数据结构为哈希表 --> key filed value 的形式,可以根据商品的分类id为 key值  filed为商品的id value存放具体商品的信息
- BitMap类型
  - BitMap数据类型是一种位图, 每个位表示一个状态 (0 / 1), 通常使用字符串来存储位图数据  --> 实现签到, 来记录用户的活跃度
- GEO 类型
  - GEO类型主要通过 经度 纬度组成, 通常使用有序集合(Sorted Set)来存储地理位置信息 --> 实现附近店铺的查询 GEOSearch 根据成员的经纬度 半径 矩形范围 原型范围进行查询, 返回满足成员的坐标
- HyperLogLog类型
  - HyperLogLog是一种基数算法, 可以接收大量的输入数据, 并使用固定的空间下 16kb 给出接近准确的技术估值, 通过String数据类型来存储 --> 统计用户访问量(每个用户只会统计一次, 不会重复统计)  



# Redission 分布式锁

答 : 