#  Java 编程入门篇

**java 编程注意的细节**

![image-20211012104634540](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110121046753.png)

## 1.Java的快速入门（转义字符）

### 1.1Java的转义字符

![image-20211012105949326](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110121059433.png)

```java
public class ESC{

	public static void main(String[] args) {
	//在控制台，输入 tab 键，可以实现命令补全
	// \t ：一个制表位，实现对齐的功能
		System.out.println("南京 \t 徐州 \t 无锡\t");
	// \n ：换行符   --> 光标进入下一行
		System.out.println("世界真好\n 嘿嘿");
	// \' ：一个' \r :一个回车 System.out.println("韩顺平教育\r 北京");
		//1.输出 韩顺平教育 
		//2.\r 表示回车   --> 光标定在本行中的初始位置
		//3.北京会替代韩顺
		System.out.println("韩顺平教育\r北京");
	// \\ ：一个\
		System.out.println("这是一个\\");
	// \" :一个"
		System.out.println("老王说：\"卖瓜了\" ");
        
	//小案例
		System.out.println("书名\t作者\t价格\t销量\n三国\t罗贯中\t12\t111");
  }
}
```

### 1.2注释comment

1. 单行注释 // 

   基本格式 格式： //注释

2. 多行注释 /* */ 

   基本格式 格式： /* 注释文字 */

3. ==文档注释 /** */==

注释内容可以被JDK提供的工具`javadoc` 所解析,生成一套以网页文件形式体现的改程序的说明文档;

```java
文档注释
/**
 * @author    小白
 * @version   1.0
 * */
 通过javadoc -d  生成后文档后文件存放的位置  -author -version  文件名.java
```

![image-20211012163739313](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110121637354.png)

### 1.3DOS的基本原理（磁盘操作系统）（P33）

相对路径：==从当前==目录开始定位，形成一个路径

绝对路径：==从顶级==目录开始定位，形成一个路径

![image-20211012170645338](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110121706481.png)

1.查看当前目录是有什么内容 dir   dir d:\abc2\test200 

2.切换到其他盘下：盘符号 cd  : change directory 案例演示：切换到 c 盘 cd /D c: 

3.切换到当前盘的其他目录下 (使用相对路径和绝对路径演示),  

..\表示上一级目录 案例演示： cd  d:\abc2\test200 cd ..\..\abc2\test200 

4.切换到上一级： 案例演示： cd  .. 

5.切换到根目录：cd \ 案例演示：cd \

6.查看指定的目录下所有的子级目录 tree 

7.清屏 cls [苍老师] 

8.退出 DOS exit 

 9.说明: 因为小伙伴后面使用 DOS 非常少，所以对下面的几个指令，老韩给大家演示下, 大家了解即可 (md[创建目 录],rd[删除目录],copy[拷贝文件],del[删除文件],echo[输入内容到文件],type,move[剪切]) => Linux

____

- *JDK JRE JVM的关系 :*

JDK = JRE + Java开发工具

JRE = JVM + 核心类库

____

## 2.Java的快速入门(变量)

### 变量

变量的基本概念：

**变量相当于内存中一个数据存储空间的表示**，你可以把变量看做是一个房间的门牌号，通过门牌号我们可以找到房 间，而通过变量名可以访问到变量(值)

变量的使用步骤：

1.声明变量

2.给变量赋值

变量的三要素：数据类型 变量名 值

### 变量的注意细节

![image-20211013090349672](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110130903759.png)

### 程序中 + 号的使用

   1.当 + 两边都是 ==整型时做加法运算==；

2. 当 + 一边整型和字符型 加法做拼接运算
3. 运算顺序从左到右； 

### 数据类型

java的数据类型

![image-20211013094808525](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110130948586.png)

基本类型：整型类型 byte short int long 

​					字符类型：char        --> 本质是一个整数,输出时,是unicode码对应的字符.

​					浮点数 float   double   输出的结果为（符号位 +指数位+ 尾数位）  --> 对于运算结果是小数的进行相等判断要小心 (小数是一个近似值)

应该是两个数的差值的绝对值,在某个范围内判断;

​					布尔类型：bool

### java API文档

API 文档网站   www.matools.com 

### ASCII码表

![image-20211013111302864](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110131113923.png)

![image-20211013111320694](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110131113740.png)

### 基本数据类型的转换（P62）

**自动转换类型**：

==低精度转换成高精度==

![image-20211013143400602](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110131434678.png)

**自动转换注意细节**

![image-20211013145716277](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110131457405.png)

----

**强制数据类型转换**

==将容量大的数据类型转换成容量小的数据类型（）强制类型转换的符号==

==强制类型转换会产生精度的溢出==

**强制类型转换的细节**

![image-20211013150424239](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110131504369.png)

----

**基本 数据类型和String类型的转换**

```java
//基本数据类型转化成字符串

			int a1=12;

			String s1 = a1+ "";

			System.out.println(s1);
```

**String类型转换成基本数据类型**

![image-20211013153107664](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110131531711.png)

```java 
//通过包装类来转换转换
			String 	s2 = "1223";
			int 	num3=Integer.parseInt(s2);
			double  dum=Double.parseDouble(s2);
			System.out.println(num3);
			System.out.println(dum);
```

----

p62内容梳理

---

## 3.Java的快速入门（运算符）

### 3.1运算符

==算术运算符：==

![image-20211014083718369](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110140837436.png)

==注：区模的本质   a%b= a- （int）a / b* b;==



前置++ 后置++

```java

		//后置++
		int i=1;
		i=i++;	//会创建一个临时变量temp  
				//1.temp=i 2.i=i+1; 3.i=temp;
		System.out.println(i); // i = 1
		//前置++
		int i=1;
		i=++i;//也会创建临时变量temp
				// 1.i=i+1;2.temp=i;3.i=temp;
		System.out.println(i); // i = 2 
```

==位运算符==

![image-20211017095740222](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110170957311.png)

```java 
//1.~按位取反 符号
// -2 的原码为    100000000   00000000 00000000 00000010
// 反码为         111111111   11111111 11111111 11111101
// 补码为         111111111   11111111 11111111 11111110
//2.按位取反      000000000   00000000 00000000 00000001 结果为1
System.out.println(~(-2));

//2|3
//1.通过补码进行运算
// 正数三码合一   2的补码 00000000 00000000 00000000 00000010
//              3的补码 00000000 00000000 00000000 00000011
// 2.通过按位或运算的    00000000 00000000 00000000 00000011 
//最后结果为原码  正好为正数三码合一 3
System.out.println(2|3);
//2^3
//1.通过补码进行运算
// 正数三码合一  2的补码 00000000 00000000 00000000 00000010
//              3的补码 00000000 00000000 00000000 00000011
// 2.通过按位异或运算的  00000000 00000000 00000000 00000001 
System.out.println(2^3);
```

```java 
//位运算符  <<左移    右移  >> 
//左移 *2^n  右移 /2^n
System.out.println(10>>2);//10/2*2  = 2
System.out.println(2<<2);//2*2*2=8
```



==关系运算符==

![image-20211014093727620](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110140937681.png)

注：关系表达式的结果为boolean类型

==逻辑运算符==

![image-20211014095018931](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110140950983.png)

**短路与 和 逻辑与的区别:**

&& 短路与：如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高 

 &  逻辑与 ：不管第一个条件是否为 false，第二个条件都要判断，效率低；

**短路或 和 逻辑或区别：**

||短路或：如果第一个条件为 true，则第二个条件不会判断，最终结果为 true，效率高 

| 逻辑或：不管第一个条件是否为 true，第二个条件都要判断，效率低

==赋值运算符==

基本赋值运算符 = int a = 10;

 复合赋值运算符 += ，-= ，*= ， /= ，%= 

**特点：**从右向左   赋值运算符的左边  只能是变量 , 右边 可以是变量、表达式、常量

赋值运算符可以进行数据类型的转换

==三元运算符==

1. 如果条件表达式为 true，运算后的结果是表达式 1；
2.  如果条件表达式为 false，运算后的结果是表达式 2；

==运算符的优先级==

![image-20211014135245689](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110141352758.png)

1.  类符号.   ()   ， {}  ；  R---->L
2. 单目运算符
3. 算术运算符
4. 位移运算符
5. 关系运算符
6. 逻辑运算符 &  ^  |   &&  ||  
7. 三元运算符
8. 赋值运算符      R---->L

### 3.2标识符的命名==规则==和==规范==

![image-20211014140422712](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110141404813.png)

### 3.3关键字

![image-20211014141256524](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110141412585.png)

![image-20211014141308376](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110141413449.png)

**保留字**：Java 保留字：现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。

自己命名标识符时要避免使用这些保留字

 byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 var

### 3.4键盘输入

键盘的输出需要一个文本扫描器 （类）

引用类需要包

通过类的属性进行键盘的输入

```java
//键盘的输入
//1.引入包 java.util.Scanner
//2.创建类 
Scanner myscanner = new Scanner(System.in);
//3.使用类的属性
//next()字符串   nextInt()整型  nextDouble()浮点型  next().charAt(0)获取字符的方式
//4.通过键盘输入 姓名 年龄  薪水
System.out.println("请输入姓名");
String name=myscanner.next();
System.out.println("请输入年龄");
int age=myscanner.nextInt();
System.out.println("请输入薪水");
double salary=myscanner.nextDouble();
//输出数据
System.out.println("姓名\t"+name+"\t年龄\t"+age+"\t薪水\t"+salary);
```

### 3.5进制

- 二进制：0-1 ，满 2 进 1.以 0b 0B开头
- 十进制 ：0-9 ，满 10 进
- 八进制：0-7 ，满 8 进 1. 以数字 0
- 十六进制：0-15，满16进1，以数字0x 0X开头

二进制转换成八进制: 每三位一组    421

二进制转换成十六进制:每四位一组  8421

### 3.6原码 反码 补码（p102）

- 0 为 正数符号  1 为负数符号
- 正数的原码 反码 补码都相同
- 负数的反码：原码符号位不变，其余取反。
- 正数的补码：反码+1    负数的反码：补码-1
- 在计算机中，通过补码运算
- 看运行结果为原码展示

## 4.Java的快速入门（控制语句）

### 4.1控制结构

三大控制语句：

- 顺序控制
- 循环控制
- 分支控制 

### 4.2分支控制（if  else）

- 单分支

```java
import java.util.Scanner;
public   class  Cricle {
    public static void main(String[] args) {

        Scanner myscanner=new Scanner(System.in);
        System.out.println("请输入你的年龄");
        int age=myscanner.nextInt();
        if(age>18){
            System.out.println("成年人");
        }
        else{
            System.out.println("未成年");				}
    }
}
```

*润年的使用 能被4整除 不能被100整除   或者  可以被400整除* 

- 多分支

  ```java
  Scanner myscanner = new Scanner(System.in);
  System.out.println("请输入你的信誉分");
  int score=myscanner.nextInt();
  if(score==100){
      System.out.println("信用分极好");
  }
  else if(score<=99&&score>80){
      System.out.println("信用分优秀");
  }
  else if(score<=80&&score>=60){
      System.out.println("信誉分一般");
  }
  else{
  
      System.out.println("信誉分不好");
  ```

  

### 4.3 Switch分支结构

表达式中的返回值必须为: `byte short int char enum(枚举) String`

![image-20211018091430045](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110180914106.png)

![image-20230410093752845](C:/Users/JueCheng/AppData/Roaming/Typora/typora-user-images/image-20230410093752845.png)

**break退出Switch 并不是退出程序**

```java
Scanner myscanner = new Scanner(System.in);
System.out.println("请输入一个字符");
char ch=myscanner.next().charAt(0);
switch(ch){
    case 'a':
        System.out.println("星期一");
        break;
    case 'b':
        System.out.println("星期二");
        break;
    default:
        System.out.println("输入错误");
}
```

### 4.4for 循环

1. for 关键字，表示循环控制

2. for 有四要素: `(1)循环变量初始化(2)循环条件(3)循环体(4)循环变量迭代` 
3.  循环操作 , 这里可以有多条语句，也就是我们要循环执行的代码 
4.  如果 循环操作(语句) 只有一条语句，可以省略 {}, 建议不要

### 4.5 while 循环

![image-20211018103326347](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110181033498.png)

1. 循环条件是返回一个布尔值的表达式 

   2.while 循环是先判断再执行语句

### 4.6do  while 循环

循环变量初始化; 

do{ 循环体(语句); 

​	循环变量迭代; 

}while(循环条件);

1. 也返回一个布尔值
2. 但是是先执行，后判断。

### 4.7==多重循环语句==

```java
//空心金字塔while循环
//循环四层 嵌套
int i=0;
while(i<4){

    //存在空格 将空格做出来
    int num=0;
    while(num<4-i){
        System.out.print(" ");
        num++;
    }

    int j=1;
    while(j<=i*2+1){
        //空心金字塔  第一个和最后一个显示  最后一行将全部显示
        if(j==1 ||j==(i*2+1)||i==3){
            System.out.print("*");
        }
        else{
            System.out.print(" ");
        }
        j++;
    }

    i++;

    System.out.println("");
}  
//for 循环
//打印空心金字塔  //控制每一个层的星星 打印第一个和最后一个
//还是循环五行  但是每一列发生改变 
//每一列循环奇数个  
for(int i=0;i<4;i++){
    //打印空格  每一行存在的空格等于 5-当前*的个数

    for(int k=1;k<=4-i;k++){

        System.out.print(" ");
    }

    for(int j=1;j<=(i*2+1);j++){ 

        //打印第一个和最后一个
        if(j==1||j==(i*2+1)|| i==3 ){
            System.out.print("*");
        }
        else{
            System.out.print(" ");
        }

    }

    System.out.println(" ");
}

```

### 4.8跳转break语句

```java 
//生成1 到100之前的随机数
int count=0;
for(int i=0;i<100;i++){

    int rand=(int)(Math.random()*100+1);//1 到100之前的随机数
    if(rand==97){
        System.out.println("找到97");
        break;
    }
    count++;
    System.out.println(rand);
    System.out.println(count);
}
```

一般使用在Switch语句和循环语句中，用于跳出当前循环。、

![image-20211018162302125](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110181623203.png)

**字符串的比较 equals()**

### 4.9continue 跳转控制语句

概念：结束本次循环进行下次循环

### 4.10 return 控制语句（p154）

跳出所在方法->跳出当前程序

## 5.Java的快速入门（数组）

### 5.1数组、排序、查找

数组可以存放多个相同数据类型的数据，引用数据类型。

数组的定义方法1：数据类型  数组名[]=new  数据类型[大小]；

数组定义方法2：先声明 后定义。  数据类型 数组名[]

数组名 =new 数据类型[大小]

```java
//数据类型  数组名[]=new 数据类型[大小]
int arr[]=new int[3];
//数组arr中存放了三个数据  给每个数据赋值
//手动存入
// arr[0]=1;
// arr[1]=2;
// arr[2]=3;
//键盘输入数据 （动态输入数据）
Scanner myscanner=new Scanner(System.in);
System.out.println("请输入各个数据");
for(int i=0;i<arr.length;i++){
    arr[i]=myscanner.nextInt();
}
//遍历数组   通过arr.length可以获得数组的长度
for(int i=0;i<arr.length;i++){
    System.out.println("第"+(i+1)+"个元素为"+arr[i]);
}
```

### 5.2数组的赋值机制

==数组在默认情况下是引用传递，赋的值是地址==

![image-20211019095235405](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110190952520.png)



**基本数据类型改变的是值  也就是值拷贝 **

**引用数据类型拷贝的是地址 也就是地址拷贝** （共享空间） 浅拷贝 

### 5.3数组的拷贝

深拷贝不会互相影响，开辟新的空间。

```java
//数组真正的拷贝  互不影响
int arr1[]={1,2,3};	
//1.在堆区重新创建一块空间、
int arr2[]=new int[arr1.length];
//2.将数组1的值全部赋值给数组2
for(int i=0;i<arr1.length;i++){
    arr2[i]=arr1[i];
}
//3.遍历数组2
for(int j=0;j<arr2.length;j++){
    System.out.println(arr2[j]);
}
```

### 5.4函数的扩容 和 删减

```java
//给数组添加
int arr[]={1,2,3};
//创建一个新的数组
int  arr2[]=new int[arr.length+1];  //不能使用 arr.length++ arr.length为一个常量 被final修饰值不可以被改变
//将先前数组的值赋值给现在的数组
for(int i=0;i<arr.length;i++){
    arr2[i]=arr[i];
}

//将输入的数据放入新的数组中
arr2[arr.length]=num;
//将arr的指向改变成arr2的指向
arr=arr2;

//遍历数组arr
System.out.println("输出当前结果是");
for(int j=0;j<arr.length;j++){
    System.out.println(arr[j]);
}

//删除数组中数据 删除最后一位
int arr[]={1,2,3};
//创建一个新的数组
int arr2[]=new int[arr.length-1];
for(int i=0;i<arr.length-1;i++){
    arr2[i]=arr[i];
}
arr=arr2;
//遍历数组
for(int j=0;j<arr.length;j++){
    System.out.println(arr[j]);
}
```



### 5.5排序

冒泡排序

```java
//创建一个数组
int  arr[] = {11,11,33,2,46,32};
//冒泡排序 将从第一数开始所有的数进行比较 然后交换 
//并且每个数字都需要比较(最后一个数无需比较)  嵌套循环
for(int i=0;i<arr.length-1;i++){
    for(int j=0;j<arr.length-1-i;j++){
        int  temp=0;
        if(arr[j]>arr[j+1]){
            //交换
            temp=arr[j+1];
             arr[j+1]=arr[j];
            arr[j]=temp;
        }
    }
}
//遍历数组
for(int n=0;n<arr.length;n++){
    System.out.println(arr[n]);
}
```

### 5.6多维数组(二维数组)(p190)

```java

//二维数组  四行五列
//定义一个二维数组
int arr[][]={
    {1,2,3,4,5},
    {1,2,3,4,5}
};
//遍历二维数组
for(int i=0;i<arr.length;i++){
    for(int j=0;j<arr[i].length;j++){

        System.out.print(arr[i][j]+"\t");
    }
    System.out.println("");
}
```



==二维数组在内存中存取的方式==

![image-20211019153915907](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110191539001.png)

杨辉三角

```java
//杨辉三角
//打印10行杨辉三角

int arr[][]=new int[10][];
for(int i=0;i<arr.length;i++){
    //给一维数组开辟空间
    arr[i]=new int[i+1];
    //给数据赋值
    for(int j=0;j<arr[i].length;j++){

        //一维数组的第一个和最后一个都为1
        if(j==0||j==arr[i].length-1){
            arr[i][j]=1;
        }

        //其余等于上一行两个数字相加
        else{
            arr[i][j]=arr[i-1][j]+arr[i-1][j-1];
        }                                                                                                 
    }
}
//遍历数组
for(int n=0;n<arr.length;n++){
    for(int k=0;k<arr[n].length;k++){
        System.out.print(arr[n][k]+" ");
    }
    System.out.println("");
}

```

这是一个一维数组   和  二维数组   ==int[] x, y[];   ---->   int []x  一维数组   int[] y []----> 二维数组==

![image-20211019162125612](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110191621656.png)

## 6.Java的快速入门(面向对象入门)

### 6.1面向对象（基本部分）

==类和对象==

类就是**自定义** 的 数据类型       对象是类的实例化

![image-20211020083814941](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110200838035.png)

```java 
public  class  Object{
    public static void main(String[] args) {
        //类的使用  需要实例化   
        //就相同与  基本数据类型一样 数据类型  变量名   
        //不同的地方在于 类需要new 一个对象

        //数据类型 数据名  = new  数据类型  自定义数据类型的赋值方式
        //cat  为对象的引用  对象名
        cat cat1 = new cat();
        cat1.name = "小白";
        System.out.println(cat1.name);
    }
} 
//类就是自定义的数据类型
class cat{
    String name;
    int age;
    String hobby;
}
```

### 6.2==对象在内存中的布局==

![image-20211020085330328](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110200853430.png)

**成员变量**  **属性**

可以是基本数据类型  和 引用数据类型

### 6.3成员方法

**==方法的调用机制==**

![image-20211020095345038](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110200953160.png)

**成员方法的定义**

访问修饰符 

返回数据类型 方法名（形参列表..） 

{

​	//方法体

​	 语句； 

​	return 返回值; 

}

### 6.4成员方法传参机制

基本数据类型：为值传递  （形参不可以改变实参）

引用数据类型：为地址传递（形参可以改变实参)

### 6.6对象的拷贝

```java
import java.util.Scanner;
public  class  Object{
    public static void main(String[] args) {
        //创建需要拷贝的员对象
        person p = new person();
        p.age=10;
        p.name="李白";
        //需要拷贝的对象
        person p1 = new person();
        //调用拷贝方法
        p1=p.copyPerson(p);

        System.out.println("先前的姓名为 "+p.name+" 年龄为"+p.age);
        System.out.println("拷贝的姓名为 "+p1.name+" 年龄为"+p1.age);
        //判断两个对象是否独立
        System.out.println(p==p1);
    }
}
class person{
    String name;
    int age;

    public person  copyPerson (person p){
        person p1 =	new person();
        p1.age=p.age;
        p1.name=p.name;
        p1.age=20;
        return p1;
    }
}
```

### 6.7==方法的递归调用==(重要)

![image-20211021085056122](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110210850219.png)



```java
public class Recursion{
    public static void main(String[] args) {
        //阶乘

        //创建对象
        AAA  aaa =	new AAA();
        int ret = 0;
        ret = aaa.factorial(4);

        System.out.println(ret);
    }
}
class AAA {
    public int factorial (int n) {
        if (n==1) {
            return 1;
        }else {
            return factorial(n-1) * n;
        }

    }
}
```

```java
//猴子吃桃   一天吃前一天的一半加一个  规律为  (day10+1)*2=day9;

public class Recursion{
	public static void main(String[] args) {
		AAA aaa = new AAA();
		int sum = 0;
		sum = aaa.peach(9);
		System.out.println("第九天猴子还剩了"+sum+"个桃子"); 
		}
}
class AAA {
	public int peach (int n) {
		if(n == 10){
			return 1;
		}else{
		return (peach(n+1)+1) * 2;

		}
	}
}
```

### 6.8方法的重载

```java 
public class Overload{
	public static void main(String[] args) {
		
		mycaluate mycaluate = new mycaluate();
		mycaluate.caluate(1,2,'加');
	}
}
class mycaluate{
	//加法计算器
	public void caluate (int num1 , int num2 ,char a ){
	
		System.out.println(num1 + num2);
	}
	//乘法计算
	public void caluate (int num1 , int num2 ){
	
		System.out.println(num1 * num2);
	}
	//除法计算器
	public void caluate (int num1 , int num2 ,int num3){
	
		System.out.println(num1 / num2);
	}
}
```

方法重载的要求：

![image-20211023100159940](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110231002075.png)

### 6.9可变参数

基本语法：

**访问修饰符  返回类型 方法名(数据类型... 形参名) **

**{  }**

使用的条件：

在相同的类下面具有一样功能但参数个数不同 ，分装成一个方法。

```java
public class Overload {
	public static void main(String[] args) {
		var var1 =  new var();
		System.out.println(var1.varperment(10,20,30));
	}
}
class var {
	//1.int... nums 代表0个到多个int 类型的数字
	//2. nums  为一个数组
	public int varperment (int... nums){
		int ret=0;
		for(int i = 0;i<nums.length;i++){
			ret+=nums[i];
		}
		return ret;
	}
}
```

![image-20211023103454572](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110231034645.png)

### 6.10作用域

![image-20211023104500626](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110231045773.png)

==局部变量必须初始化   全局变量可以不用初始化==

==成员属性为全局变量，成员方法里的变量为局部变量==

### 6.11构造器/构造方法

==完成对象的初始化==

构造器的特点：

方法名和类名相同 没有返回值 系统会自动调用该类的构造器完成初始化。

1) 构造器的修饰符可以默认， 也可以是 public protected private 
2) 构造器没有返回值 
3) 方法名 和类名字必须一样 
4) 参数列表 和 成员方法一样的规则
5)  构造器的调用, 由系统完成

### 6.12对象创建的流程分析

![image-20211023115225545](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110231152613.png)

1. 在方法区加载类的信息
2. 在堆中分配地址
3. 完成对象的初始化（先是默认初始化 显示初始化 构造器初始化)
4. 在对象在堆中的地址，返还给（p） p为对象的引用 也为对象名

### 6.13this关键字（p262）

this关键字的本质： `this 指向当前调用的对象`

![image-20211023160524500](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110231605615.png)

1. this可以访问属性 方法  构造器
2. this可以区别成员变量 和 局部变量
3. this.方法名
4. this 不能在类定义的外部使用，只能在类定义的方法中使用
5. 访问构造器语法：this(参数列表); 注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一 条语句)



----

-----

# Java 编程基础篇（OOP）

## 1.Java的基础(IDEA的使用)

### 1.1IDEA的快捷键

1. 删除当前行  Ctrl + d
2. 复制当前行  Ctrl + r
3. 代码补全 Alt + / 
4. 导入该行需要的类 Alt +enter
5. 快速格式化代码 Ctrl + L
6. 生成构造器等 Ctrl + Alt + =
7. .var 自动生成变量名称

### 1.2IDEA自定义模板

for循环 为 fori 

输出语句为 sout 

主方法  main

### 1.3包的介绍

**包的三大作用**

![image-20211025151848238](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110251518311.png)

**包的基本语法**

![image-20211025151915396](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110251519455.png)

**包的命名规则和规范**

![image-20211025155226464](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110251552583.png)

## 2.Java的基础（访问修饰符）

### 2.1访问修饰符

1. public 对外公开
2. protected  保护 对同一个包和子类可以使用
3. 默认 对同一个包可以使用
4. private  私有 只能在同一个类中使用

![image-20211026154311435](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110261543491.png)

![image-20211026154324690](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110261543766.png)

## 3.Java的基础（封装）

### 3.1封装

封装的概念： `将对象成员私有化,通过对象中的公共方法对私有成员进行操作(过程中可以添加规定私有成员必须满足的条件)`

![image-20211028111823261](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110281118324.png)

封装的三部曲：

1. 创建私有的属性 外部不可以修改 保证属性的安全性
2. 创建一个公共的public  set 方法 可以在set方法中修改属性   public void setXXX{满足一定的条件}
3. 创建一个公共的public get 方法 可以通过get方法获得属性 public  返回的数据类型 getXXX { return }

==总结：将抽象的数据属性和方法封装在一起，数据被保护在内部 ，其它部分只能通过特有的方法才能进行数据的操作==

### 3.2封装和构造器

当数据需要判定时，可以将setXXX写到构造器中 这样任然可以进行验证。

![image-20211027160713449](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110271607504.png)

## 4.Java的基础（继承）

### 4.1继承

两个类许多具有相同属性和方法的时候，继承可以减少代码的使用。

==继承---->代码的复用==

![image-20230708151845998](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20230708151845998.png)

继承的基本语法：

class 子类 extends 父类{

}

![image-20211027172652362](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110271726477.png)

**继承的细节（p289）**

### 4.2继承的本质

==子类继承父类在内存中发生的变化==

![image-20211027174808043](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110271748115.png)

==当在子类中执行属性 方法 时，根据名称先在子类中查找 ，然后再慢慢向上查询==

### 5.1super关键字（继承）

基本内容：super 可以访问父类的属性 方法 构造器

==super的基本语法：==

super可以引用父类的属性  super.属性名 但是私有的除外

super可以引用父类的方法 super.方法名（参数） 一样私有除外

**super 可以访问父类的构造器   必须在子类构造器里面第一条语句就是super（）**

==super的用法==

![image-20211028095606889](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110280956000.png)

this.方法名

方法名   ---->访问效果都是先在本类查找  

super.方法名称  ==跳过本类 在父类查找==（**当属性和方法重名的时候，通过super.属性或者方法会直接去访问父类的属性和方法**）

**super 和 this 的区别**

![image-20211028102722576](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110281027668.png)

### 6.1方法的重写/覆盖(继承)

概念：子类的方法的形参列表 和 方法名称  返回类型 要和父类相同（完全一样）

![image-20211028105704835](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110281057952.png)

**重载和重写的区别**

![image-20211028110219486](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110281102548.png)

## 5.Java的基础（多态）

### 7.1多态

多态的基本介绍：

==多态是建立在继承和封装的基础上的==

方法的多态：

重写和重载的体现

==对象的多态==

![image-20211028113421357](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110281134429.png)

- 一个对象编译类型和运行类型可以不一样
- 编译类型不可以改变
- 运行类型是可以改变的
- 编译类型在等号的左边，运行类型在等号的右边

==总结：多态就是方法和对象的多种体现，建立在封装和继承的基础上，OOP的三大特征之一。==

==方法多态的体现：重写 重载==

==对象的多态体现：编译类型和运行类型不一致，  编译类型在定义对象的时候就确定了，不能被改变==

==运行类型可以改变 等号左边是编译类型 右边是运行类型==

### 7.2多态的向上转型

本质：父类的引用指向子类对象

语法：父类类型 引用名称 = new 子类类型

特点：可以调用父类中的所有成员 （通过访问权限），

不能调用子类的特有成员，可以调用子类中的重写父类的方法

最终运行看子类中的具体体现。

**总结：**

==运行的过程先编译 后运行 在编译过程中无法调用子类的特殊成员，因为编译类型是父类。==

==但在运行的过程中，运行类型是子类所以先从子类中编译通过的方法开始运行，再向上查找==

### 7.3多态的向下转换

语法：子类类型  子类名称 = （子类类型） 父类引用    -->  子类类型 子类名称  =   new 子类类型()

特点：可以调用子类中的特殊属性， 

但是不能是父类的对象必须是父类的引用，

父类的引用必须指向当前的对象

**总结**：

==想要调用子类中特殊的方法通过下转的方式，最后将编译类型 和运行类型全部相同了，所有可以调用子类的特殊方法。==



**属性没有重写一说，属性的值看编译类型**

**instanceOf 比较操作符，用于判断对象的运行类型是否为 XX 类型或 XX 类型的子类型**

### 7.4Java的动态绑定机制（Very Very Very  Imporant）

![image-20211030153956483](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110301539555.png)

**该方法会和该对象的运行类型绑定**

**属性没有绑定机制，那里声明，那里使用。**

### 7.5多态的应用

==多态数组==

```java
package com.PolyArray;

public class Test {
    public static void main(String[] args) {
        //创建对象数组
        Person[] person = new Person[3];
        //向上转型
        person[0] = new Person("张飒",23);  
        person[1] = new Student("李白",34,342); 
        person[2] = new Teacher("猴子",32,12345);
        //遍历数组
        for (int i = 0; i <person.length ; i++) {
            //Java的动态绑定机制   方法和对象的运行属性 绑定   属性没有绑定那里声明那里使用
            System.out.println(person[i].Show());
            if(person[i] instanceof Student){
                ((Student)person[i]).method();
            }else if(person[i] instanceof Teacher){
                ((Teacher)person[i]).method();
            }else{
                System.out.println("你为Person类型 或者 类型有误");
            }
        }

    }
}
```

==多态参数==

```java 
package com.Polyparameter;

import com.PolyExample.Master;

public class Test {
    public static void main(String[] args) {
        Test test_method = new Test();
        Manager manager = new Manager("李白",13456,10000);
        Common_employ common_employ = new Common_employ("孟浩然",8779);

        test_method.showEmpAnnual(manager);
        test_method.showEmpAnnual(common_employ);

        test_method.testWork(manager);
        test_method.testWork(common_employ);

    }
    
    public void showEmpAnnual(Employee e){
        System.out.println(e.getAnnual());
    }

    public  void testWork(Employee e ){
        if(e instanceof Common_employ){
            ((Common_employ)e).work();
        }else if (e instanceof  Manager){
            ((Manager)e).manager();
        }
    }
}
```

## 6.Java的基础（Object类的方法）

### 8.1Object 类的详解

### 8.2 equals方法

====和 equals的比较==



== 判断基本类型（判断值）  和  引用类型（判断地址） 是否相同

![image-20211031095905408](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110310959507.png)



==Ctrl + b 直接查看源码==、

![image-20211031101103713](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110311011801.png)

**String 重写了Object 类的 equals方法来进行判断 判断内容**    ==String中equals 源码==

```java
    public boolean equals(Object anObject) {
        if (this == anObject) {//先判断是否为相同的对象  / 相同的地址
            return true;
        }
        if (anObject instanceof String) {  //判断传入的对象是否为 String类型 或者String的子类
            String anotherString = (String)anObject; //进行向下转化  
            int n = value.length; //当前对象的内容长度
            if (n == anotherString.value.length) {//先判断内容长度是否相同
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {//进行字符串的一一比较
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
```

**Integer 重写了Object 类的equals 方法进行判断  判断内容是否相同 **  ==Integer中equals源码==

```java
public boolean equals(Object obj) {
    
        if (obj instanceof Integer) {
            
            return value == ((Integer)obj).intValue();
        }
        return false;
    }
```

**总结：equals 在Object类中，用来判断对象是否相同**

**String类重写了equals 所以判断字符串是否相同、**

**Integer也重写了equals 所以判断内容是否相同**

### 8.3hashCode方法

- hashCode  可以提高容器的效率
- 两个引用指向同一个对象hashcode值相同
- 两个引用指向不同的对象hashcode值不同
- hashCode获得不是地址根据地址符号所获取的

### 8.4toString方法

**toString的源码   toString ()是Object类的方法  可以在子类中重写** 

```java
  public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
```

``**返回 全类名(包名+类名) + @ 哈希值的十六进制 ``**

**重写的toString方法一般返回类的属性值**  可以通过IDEA快捷键直接进行创建

```java
 public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", gender=" + gender +
                '}';
    }
```

### 8.5finalize方法

![image-20211031115640758](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202110311156841.png)

### 9.1断点的调试

![image-20211101085601997](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202111010856077.png)

**注意:在断点调试的过程中，是运行状态，所以以对象的运行状态执行。**

==Debug的快捷键：F8向下进行 F7进入方法 Shift+F7强制进入Shift +F8退出本层方法 F9动态进入两断点之间== 

----

### 出租屋分析

![image-20211104091205943](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202111040912105.png)

---

# Java 编程提高篇（OOP）

## 1.Java的提高（static变量）

**类变量(静态变量)定义：在对象中定义一个变量，通过static来修饰，会被所有的 相同类 的对象实例共享;静态变量在类加载的时候就生成了**

静态变量在内存空间存储: JDK7之前存放在方法区里的静态域中;JDK8之后存放在class实例中(类信息加载时生成)



**类变量的语法**：

static 数据类型   变量名

static 访问修饰符  数据类型 变量名



**访问类变量**：

类名.类变量(推荐)   /  对象名.类变量

**类变量的内存分析:**

![image-20211104102918042](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202111041029104.png) 

==类变量的细节==

- 当某个类的 所有对象 需要访问同一个变量的时候使用
- 类变量和实例变量的区别：类变量是所有相同类对象共享的，实例变量是每个对象单独的。
- 加上static 就叫静态变量  ，其余的叫普通变量/实例变量/非静态变量
- 静态变量的访问  --- > 类名.静态名称/类变量
- 类变量在类加载的时候，就已经创建了，不创建实例化对象就可以类变量了；
- 类变量的生命周期伴随着类的消亡而消亡。



*总结：*

**1.类变量会被所有相同类的对象实例共享**

**2.类变量在类加载的时候，就已经产生。**

---

**类方法定义：在对象中定义一个方法，通过static来修饰，会被所有的 相同类 的对象实例共享**

**类方法的基本语法：**

访问修饰符 static  返回类型 方法名  （参数）{代码块} 

 static 访问修饰符  返回类型 方法名  （参数）{代码块} 

**类方法的调用：**

类名.类方法名     类方法可以访问类变量

==静态方法的运行场景==

静态方法中==不涉及到任何和对象相关==的成员，则可以将方法设计成静态方法,提高开发的效率。

- 不创建实例就可,调用某个方法(即当成工具来使用)

==类方法的细节==

1. 在类方法中，（不存在this的参数  普通方法中存在this的参数） 不允许访问和对象相关的关键字(例如: super,this)
2. ==类方法和普通方法都是随着类的加载而加载,将信息存储在方法区中==;
3. 类方法可以通过 类名.类方法名/对象名.类方法名
4. 类方法只能访问==类变量/类方法==
5. 普通的方法 可以访问静态成员 也可以访问非静态成员

**总结：静态方法只可以访问 静态成员；非静态方法可以访问所有成员；在编写代码的时候，要注意访问修饰权限。**

-----

## 2.Java的提高（main 语法）

**解析 public static void main( String [] args)**

1. JVM虚拟机调用 main()方法
2. 访问权限为public    -->  Java虚拟机和main()方法所处位置不同,只能设置访问权限为public,确保Jvm可以100%访问main()方法
3. 设为static方法 -->  调用main()方法无需实例化对象
4. 返回类型为void  -->  main()方法没有返回值
5. 参数为 String[]  -->  String类型的数组参数,该数组中保存执行java命令时传递给所有运行的类的参数
6. java执行的程序 参数1 参数2 参数3

![ ](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202111061417713.png)



**在main方法中，我们可以直接调用该类中静态成员，不可以调用非静态成员。(main方法就是类方法 --->只能调用类方法和类变量)**

----

## 3.Java的提高(codeblock) 

**代码块的定义：代码块属于类的一部分,提高代码的效率**

简介 : 代码块属于类的成员[类的一部分],==类似于方法==,将逻辑语句封装在方法体中,通过{}包围起来;

没有方法名,没有返回,没有参数,只有方法体,不是通过对象或者类显示调用,而是==在加载类时或者创建对象时隐式调用==



**基本语法格式：**

【修饰符】{代码；

}；

1. 可写可不写，但是只能写static
2. 代码块分为两种 静态代码块和非静态代码块
3. 代码可以是任何逻辑语句（输入 输出 判断 循环 方法调用等） 



==代码块细节：==

`代码块的执行优先构造器和成员方法`

1. static 代码块 静态代码块，它伴随==类的加载==进行执行，并且==只会执行一次==; 普通代码块(放在构造器中)和对象的创建相关 --> 普通代码块每当创建一个对象代码块就会执行一次 。
2. ==类什么时候会被加载：==
   1. ==当通过new创建对象时，类会被加载；==
   2. ==子类实例化对象时，父类会被加载（父类先被加载，子类后被加载）；==
   3. ==使用类的静态成员(类方法 类属性)时;==

3. 普通的代码块，当对象被创建一次就会调用一次；`使用类的静态成员，普通代码块不会被调用,静态代码块会被调用`。
4. ==创建一个对象==时,在一个类中调用顺序是(==重点==):
   1. 调用静态代码块和静态属性初始化 (它们两个的优先级一致,根据定义顺序调用  类加载时被调用一次)
   2. 调用普通代码块和普通属性的初始化 (它们两个的优先级一致,根据定义顺序调用 创建对象就会被调用)
   3. 调用构造器(构造方法)

5. 静态代码块只能调用静态成员,普通代码块可以调用任意成员;



**总结：当在new 创建对象时，必先加载类--->静态的代码块就会被执行；**

**创建完对象后普通代码块会被执行，最后执行构造器的内容。**

`构造器底层显示:`

构造器中{

//(1).super();

//(2).调用本类普通代码块或者普通成员属性初始化

构造器语句；

}

----

## 4.Java的提高（final关键字）

**final 可以修饰类 属性 方法 局部变量**

==final的四种 用法==

1. 当不希望类被继承的时候，在类前加上 final 关键字
2. 当父类中的方法不希望被子类重写或覆盖的时候，在方法前加上关键字final
3. 当类中的属性不想被修改时，加上final关键字(`类似全局常量功能`) 
4. 当局部变量不想被修改时，final关键字(`类似局部常量`)

==final 使用的细节==

1. final修饰的属性为常量 ，命名方法为 XX_XX，==不能被修改==。
2. final 可以有三种赋值的地方  ==定义时赋值；代码块中赋值； 构造器中赋值==
3. 如果final修饰的属性为静态的，==只能在定义时赋值，或者在静态代码块中赋值==。
4. final类不可以继承，但是可以实例化对象;
5. 如果类不是final类，但是存在final类方法，也是可以继承的只是不可以重写/重载该方法 ，但是可以使用父类中final修饰的方法。
6. 当类被final修饰时，其方法不需要加final关键字
7. final不可以修饰构造方法(构造器)
8. final 和 static 往往搭配使用 ，效率更高，==不导致类的加载也可以使用静态变量==,底层编译器做了优化 ；
9. 包装类（Double，Integer，Float，Boolean）和String类 不可以被继承  由于他们是 final 类  

----

## 5.Java的提高（abstract类）

==快速入门==

当父类中的一些方法不确定的时候，可以通过  abstract 类进行修饰，从而变成抽象方法但是类也需要变成抽象类。

抽象方法会让子类（继承）进行实现；

==抽象类的介绍==

![image-20211110104716617](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202111101047786.png)

==抽象类的细节==

1. 抽象类==不可以==被实例化  --> 通过向上转型  (多态的应用)
2. 抽象类不一定要存在abstract方法，也可以具有其他方法;
3. 一旦这个类包含类抽象方法，则类必须声明为抽象类。
4. ==abstract只能修饰类和方法== ，不可以修饰属性和其他。 
5. 抽象类可以有任意的成员（抽象类本质还是类）
6. 抽象方法不能有主体
7. 如果一个类继承了抽象类，它必须实现抽象类的所有抽象方法，除非它自己也声明为抽象类。
8. 抽象类 和 抽象方法不可以被 private  final  static 这些关键字修饰 ，因为他们无法让子类重写。



**抽象类的最佳实践 ————>模板设计模式 :** 

提高代码的复用性 通过继承和抽象类 一起实现

----

## 6.Java的提高（interface） 

基本介绍：Interface就是给出一些==没有实现的方法,封装到一起==,到某个类要使用的时候,在根据具体情况把这些方法在类中实现;

`注: 在JDK7前,接口里的所有方法都没有方法体即都是抽象方法;`

`JDK8后接口可以有static方法 default方法 abstract方法,接口可以做到方法的具体实现`

![image-20211110134610474](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202111101346557.png)



**小结：在接口中存在属性和方法 方法有三种（1.抽象方法 abstract 2.默认方法需要关键字default修饰3.静态方法 static;**

**属性是被public final static修饰为公共静态常量**

==接口使用的细节==

1. 接口==不可以被实例化== （本身就是抽象的概念）
2. 接口中的方法是public方法 ，接口中抽象方法可以省略abstract；
3. 一个普通类实现接口，就必须将该接口的所有抽象方法都要实现; 快捷键(alter +enter)实现Interface接口方法
4. 抽象类去实现接口时可以不用实现接口的抽象方法
5. 一个类可以同时实现多个接口
6. 接口中的属性只能是final修饰,被 public static final 修饰的  通过 ==接口名.属性名调用==直接调用
7. 接口不可以继承类 但是可以继承其他的多个接口
8. 接口的修饰符只能是默认和public 这点和类相同。



### 6.2接口 和 继承的对比

接口 是 对单继承的一种补充,Interface可实现多继承  (感觉接口就是一个可以实现多继承的抽象类)

接口可以扩展能力 

**小结：当子类继承父类，就自动拥有了父类的能力；当子类需要扩展能力，可以通过实现接口的方式,子类需要实现接口里面的方法； **

**接口就是对java单继承机制的补充**

![](https://notebook-img.oss-cn-shanghai.aliyuncs.com/old-img/202111101503785.png)

### 6.3接口的多态特性

==多态参数==

`当方法里的参数为接口类型时,可以传入implement接口类 的实例对象`

接口类型的变量   可以 指向实现接口的类的对象实例  ==>  UsbInterface usbinterface   ->   new Phone();

==多态数组==

```java
package OOP_Improve.Interface_.Interface_ploy;

import java.lang.invoke.CallSite;

public class Test {
    public static void main(String[] args) {
        //创建一个USb 数组 -->  接口类型的数组
        USb usb [] = new USb[2];
        // Phone 和 Camera 为实现Usb接口的类 
        usb[0] = new Phone();  // 向上转型   前提类实现该接口   
        usb[1] = new Camera();
        //调用 接口的方法
        usb[0].work();
        usb[1].work();
        //如何实现特别的方法 call方法  向下转型  （盲猜）
        Phone phone = (Phone)usb[0];
        phone.call();
    }
}

interface Usb{
    void work();
}

// 实现Usb接口
class Phone implements Usb{
    // 重写方法
    public void work(){
        System.out.println("手机在工作")
    }
    //特有方法
     public void call(){
        System.out.println("手机可以打电话")
    }
}
// 实现Usb接口
class Camera implements Usb{
    // 重写方法
    public void work(){
        System.out.println("相机在工作")
    }
}

```

==接口存在多态传递==

```java
package OOP_Improve.Interface_.Interface_ploy;

import OOP_Improve.Abstract.Formwork.AA;

public class Interface_ploy_pass {
    public static void main(String[] args) {
        //接口 aa 可以指向 实现接口类对象的CC
        AAA aa = new CC();
        //当BB 继承了 AAA 就可以实现 BB指向 CC
        BB bb = new CC();

    }
}
interface AAA extends BB{}
//当 AAA 继承了 BB  时 就可以实现 BB 指向 CC
interface BB {}
class  CC implements  AAA{ }
```

## Java的提高（==innerclass==）

---

```java
	//类的最终形式展现
package com.banne.design; // 包名
class Test extends TestFather implements TestAbility{
    //成员属性
    int age;
    //成员方法 and 实现类中的抽象方法
    public void Say(){...}
 
    //构造器
    public Test(int age){
        //super()  实现父类的初始化
        //{}       实现代码块
        //构造器中语句
    }
    //内部类
    
}
```



**类的五大成员——>成员属性，成员方法，构造器，代码块，内部类**

---

==基本介绍==

一个类的内部又完整的嵌套另一个类，被嵌套的类称为内部类 （inner class）,外面的类称为（outer class）

内部类==可以直接访问类内的私有属性==，体现类与类之间的包含属性。

==基本语法==

```java 
class Outer{  //外部类
     class Inner{  //内部类
        
    }
}
class Other{ //其他类
}
```

 

### 内部类的分类

**内部类分为两部分为四种：**

第一部分：

将内部类定义在外部类局部位置上（定义在方法内/或者代码块内）

1. 局部内部类（具有类名）
2. 匿名内部类（没有类名！！！！）

第二部分：

将内部类定义在成员位置上

1. 静态内部类（static修饰）
2. 成员内部类（没有static修饰）



==局部内部类的细节==

1. 定义在代码块或者方法体
2. 可以直接访问外部类的所有成员 ==包括私有成员==
3. 可以被final修饰  
4. 不可以被访问修饰符修饰  --> 地位为局部变量,局部变量不可为访问修饰符修饰
5. 外部其他类不可以直接访问局部内部类（相当于局部变量）
6. 外部类访问内部类需要实例化内部类 
7. 内部类的本质还是一个类
8. 如果外部类和内部类 的成员重名 采用就近原则 ，如果想调用外部类的成员通过（外部类名.this.成员名称 --> 外部类名.this本质为外部类的对象,谁调用了该方法,外部类名.this就指向谁）



**小结：（1）局部内部类所在的位置-->方法体或者代码块（2）作用域:方法体或代码块中（3）本质还是一个类(4) 内部类类似于局部变量**

```java
package OOP_Improve.InnerClass;

import java.security.PrivateKey;

public class Innerclass_PartClass {
    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.Part();
    }
}
class Outer {
    private int num = 19;
    public void  say(){
        System.out.println("你好呀");
    }
    //    1. 定义在代码块和方法内部
    
    public void Part(){
//        2. 可以被final修饰 不可以被访问修饰符修饰
       final class  inner{
            private int num1;

            void say2(){
                System.out.println("内部类的方法");
                //3. 可以直接访问外部类的成员方法
                say();
            }
            //4. 可以直接访问外部内部类的所有属性包括私有属性
            void show(){
                System.out.println("num = " +num);
            }
        }
//        5. 外部类访问内部类需要实例化内部类
        inner inner = new inner();
        inner.say2();
        inner.show();
    }
}
```



==匿名内部类细节==

**包含：（1）继承 （2）多态 （3）动态绑定机制（4）内部类**

（1）本质为类（2）内部类（3）匿名（系统定义名称，在底层可以观察到）（4）匿名内部类还是个对象

基本语法：

new 类或者接口 （参数列表）{

​		类体

}；

匿名内部类来简化开发  匿名内部类的细节几乎和局部内部类的细节相同

1. 匿名内部类 当    new 类名(参数列表){} -->  执行的操作
   1. 本质1:-->  相当于class 匿名类名 extends 类名{}   (其中包含向上转型,编译类型为类名  运行类型为匿名类) 
   2. 本质2:--->  相当于编译类型 名称 = new 匿名内部类()  
2. 当 new 接口(参数列表)  --> 本质为 class 匿名类名 implements 接口名{} (其中包含向上转型,编译类型为接口类型   运行类型为匿名类)
3. 定义在代码块和方法内部
4. 可以直接访问外部类的所有成员 ==包括私有成员==
5. 不可以被访问修饰符修饰  --> 地位为局部变量,局部变量不可为访问修饰符修饰
6. 外部其他类不可以直接访问局部内部类（相当于局部变量）
7. 如果外部类和内部类 的成员重名 采用就近原则 ，如果想调用外部类的成员通过（外部类名.this.成员名称 --> 外部类名.this本质为外部类的对象,谁调用了该方法,外部类名.this就指向谁）
8. 无法在创建匿名类的方法体中使用匿名内部类的特有 属性 和 方法



**外部其他类不可以访问匿名内部类**



==匿名内部类的使用==

存在两种语法格式

```java
//第一种格式    
public void Detail(){
    //创建匿名内部类  底层体现为 class Anonymous extend GrandFather
    GrandFather grandFather =  new GrandFather("李白"){
        @Override
        public void say() {
            super.say();
            System.out.println("这是重写后的方法");
        }
    };
    //运行类型为 Anonymous&1 
    grandFather.say();
}
//第二种格式
public void Detail(){
    //创建匿名内部类
    new GrandFather("李白"){
        @Override
        public void say() {
            super.say();
            System.out.println("这是重写后的方法");
        }
    }.say();
}

}
```



==成员内部类==

1. 可以直接访问外部类的所有成员包括 私有属性
2. 成员内部类定义位置在于成员位置上
3. 外部类访问内部类需要实例化内部类 
4. 可以添加任意的访问修饰符，因为它的地位是一个成员
5. **外部其他类也可以访问成员内部类**

访问的两种方法

```java
//本质就是个语法   main为外部类Main的实例对象   Member为内部类
Main  main = new Main();
Main.Member member = main.new Member();
member.say();
//创建函数返回 成员内部类
Main.Member member1 = main.getMember();
member1.say();
```



==静态成员内部类==

1. 可以直接访问外部类的静态成员 包括私有的
2. 静态成员内部类定义在成员位置上
3. 外部类访问静态成员内部类  创建内部类对象再访问
4. 可以添加任意访问修饰符
5. 外部其他类也可以访问静态成员内部类
6. 外部类和静态成员内部类成员重名时,静态内部类访问时,默认遵循就近原则;如果想要访问外部类的成员通过==外部类名.成员==

```java
//静态 成员内部类 可以通过类名访问
Static_main.Static_member static_member = new Static_main.Static_member();
static_member.show();
//创建一个方法 返回静态内部类的实例对象
```

------

## Java的提高(enum)

简介 :  将具体的对象一个一个列举出来  --> 

`使用枚举是将构造器私有化,无法在外部创建对象,只能使用开发者列举好的类;枚举属于比较特殊的类,里面只包含一组有限的特定对象`

场景 :  创建一个Season类,自然而然规定好只能创建春 夏 秋 冬四个对象,这时就使用枚举操作.

### 自定义类实现枚举 :   

1. 将构造器私有化，无法在外部实例化对象  --> 只能使用内部枚举好的对象
2. 去掉setXXX 方法  --> 防止外部修改枚举对象的成员属性
3. 对枚举对象和属性 通过 ==final static== 来修饰 便于底层的优化 --> final static 一起使用,类无需加载;
4. 枚举根据类的属性创建对象  

```java
package com.oopImprove.enum_;

public class Enum {
    public static void main(String[] args) {
        // 5.展示 枚举对象
        System.out.println(Season.AUTUMN);
    }
}
class Season{
    private String name;
    private String desc;
    //1.私有化构造器  --> 外部无法实例化对象
    private Season(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    //2.只存在get方法 -->  防止属性被外部修改  
    public String getName() {
        return name;
    }
    public String getDesc() {
        return desc;
    }
    //3.在Season中创建 固定的对象  通过fianl static修饰符优化代码  final static 一起修饰可以不加载类
    public final static Season SPRiNG = new Season("春天","温暖的");
    public final static Season SUMMER = new Season("夏天","炎热的");
    public final static Season AUTUMN = new Season("秋天", "凉爽的");
    public final static Season WINTER = new Season("冬天","寒冷的");

    //4.重写toString方法  方便观察输出信息
    @Override
    public String toString() {
        return "Season{" +
                "name='" + name + '\'' +
                ", desc='" + desc + '\'' +
                '}';
    }

}
```

### 使用关键字enum实现枚举

```java
package Enum_Explain;

/**
 * @author Tian
 * @version 1.0
 */
public class Enum_keyword {
    public static void main(String[] args) {
            System.out.println(Season2.SPRING);
    }
}
enum Season2{   // 底层 public final class Season2 extends Enum
    //3.使用了enum关键字来实现枚举类
    /*
    *使用枚举关键字代替 class
    *  自定义实现枚举类中创建常量对象为  public final static Season SPRiNG = new Season("春天","温暖的");
    *  使用enum关键字创建对象为  常量名称(实参列表)  -->  SPRiNG("春天","温暖的")
    *创建多个常量对象使用 逗号(,)隔开即可
    *使用enum来实现枚举,要求将定义常量对象(枚举对象)必须放在枚举类首行
    */
    SPRiNG("春天","温暖的"),SUMMER("夏天","炎热的");

    private String name;
    private String desc;
    //1.私有化构造器  --> 外部无法实例化对象

    private Season2(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    //2.只存在get方法 --> 防止属性被修改
    public String getName() {
        return name;
    }
    public String getDesc() {
        return desc;
    }

    //4.重写toString方法  方便观察输出信息
    @Override
    public String toString() {
        return "Season{" +
                "name='" + name + '\'' +
                ", desc='" + desc + '\'' +
                '}';
    }
}
```

### Enum的细节

1. 使用关键字enum开发一个枚举类时,会默认继承Enum类而且;  被enum修饰的类还被final修饰无法被继承
   1. ![image-20211113150516405](https://banne.oss-cn-shanghai.aliyuncs.com/Java/202111131505516.png)

2. 如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略;
3. 当有多个枚举对象时，使用逗号(,)间隔，最后有一个分号结尾
4. 枚举对象必须放在枚举类的行首.

### Enum常用方法

```java
package com.oopImprove.enum_;

import com.sun.corba.se.impl.encoding.CDROutputObject;

import javax.naming.directory.SearchControls;

public class Enum {
    // 展示枚举类的常用方法
    public static void main(String[] args) {
        // 枚举类  类名 --> 枚举常量对象
        Season2 season = Season2.SUMMER;
        //1.name()方法  --> 输出当前枚举常量对象的名称
        System.out.println(season.name()); // SUMMER
        //2.ordinal()方法 --> 输出当前枚举常量对象的编号(从0开始编号)
        System.out.println(season.ordinal());//1
        //3.compareTo()方法 --> 比较两个枚举常量对象 比较的其实就是编号
        System.out.println(season.compareTo(Season2.SPRiNG)); // -->  Season2.SUMMER.ordinal() - Season2.SPRiNG.ordinal() 
        
        //4.valueOf(参数)方法 --> 将字符串转换成枚举常量对象,要求字符串为已有的枚举常量对象名,否则报错
        Season2 summer = Season2.valueOf("SUMMER"); //Season2 summer1 = Season2.SUMMER
        System.out.println("autumn="+ summer);
        Season2 summer1 = Season2.SUMMER;
        System.out.println("autumn="+ summer1);
        System.out.println(summer1 == summer); // true  两者输出内容相同 都是指向 SUMMER枚举常量对象
        
        //5.values()方法 --> 返回Season2[](枚举Season2类型的数组),含有定义的所有枚举常量对象
        Season2[] values = Season2.values();
        for (Season2 season1:values) {//增强for循环  --> 从values数组中取出数据赋值给season1,取完退出循环
            System.out.println(season1); // (没有重写toString方法输出枚举对象的名称) SPRiNG    SUMMER (存在重写toString方法则输出toString方法展示的内容)
        }
    }
}
enum Season2{ //底层 public final class Season2 extends Enum
    //3.使用了enum关键字来实现枚举类
    /*
    *使用枚举关键字代替 class
    *  自定义实现枚举类中创建对象为  public final static Season SPRiNG = new Season("春天","温暖的");
    *  使用enum关键字创建对象为  常量名称(实参列表)  -->  SPRiNG("春天","温暖的")
    *创建多个常量对象使用 逗号(,)隔开即可
    *使用enum来实现枚举,要求将定义常量对象放在成员属性之前*/
    SPRiNG("春天","温暖的"),SUMMER("夏天","炎热的");

    private String name;
    private String desc;
    //1.私有化构造器  --> 外部无法实例化对象

    private Season2(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    //2.只存在get方法 --> 防止属性被修改
    public String getName() {
        return name;
    }
    public String getDesc() {
        return desc;
    }

    //4.重写toString方法  方便观察输出信息
    @Override
    public String toString() {
        return "Season{" +
                "name='" + name + '\'' +
                ", desc='" + desc + '\'' +
                '}';
    }
}
```

### Enum实现接口

1. 枚举类不可继承其他类(==继承过Enum类了==),也不可被其他类继承(==被final修饰==) --> enum类的本质: public final class 枚举类名  extends Enum
2. 枚举类一样可以实现接口操作

```java
package com.oopImprove.enum_;

/**
 * @author Tien
 * @version 1.0
 */
public class EnumPractice {
    public static void main(String[] args) {
        
        Week Monday = Week.MONDAY;
        Monday.Test();// 可以调用枚举类中的普通成员方法
        Monday.showInfo();//枚举类一样可以实现接口里的抽象方法
    }
}
// 创建一个接口 Inter
interface Inter{
    void showInfo();
}
enum Week implements Inter{  // 底层本质为  final class Week extends Enum
    MONDAY("星期一"),TUESDAY("星期二"),WEDNESDAY("星期三"),THURSDAY("星期四"),FRIDAY("星期五"),SATURDAY("星期六"),
    SUNDAY("星期天");
    private String desc;
    Week(String desc) {
        this.desc = desc;
    }
    //普通方法
    public void Test(){
        System.out.println("枚举类可调用");
    }
    // 实现接口
    @Override
    public void showInfo() {
        System.out.println("枚举类一样可以实现接口");
    }
}
```

---

## Java的提高(annotation)

简介 : 注解的本质是一个类@interface,和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息;

*三个基本的注解 :*

- @Override: 限定某个方法,是重写父类方法,该注解`只能用于方法`
- @Deprecated:  用于表示某个程序元素(类, 方法等)已过时
- @SupperssWangings: 抑制编译器警告

### @Override

```java
class Father{
    int age;

    public Father(int age) {
        this.age = age;
    }
    public void Say(){
        System.out.println("正在说话!!!");
    }
}
class Son extends Father{
    String name;

    public Son(int age, String name) {
        super(age);
        this.name = name;
    }
    /* 1.@Override注解出现在 Say()方法上,表示重写了基类的Say()方法
       2.如果方法前有@Override注解,编译器会进行检查该方法是否真的重写了基类的方法,重写编译通过,没有重写则编译错误;
       @Override目的 --> 检测下面被修饰的方法是否重写基类的方法  (只能用于方法)
     */
    @Override
    public void Say() {
        System.out.println("我正在说话 ! ! ! ");
    }
}
```

@Override 底层源码

```java
@Target(ElementType.METHOD)  // -->可修饰的目标
@Retention(RetentionPolicy.SOURCE) // 注释作用到源文件
public @interface Override {  // @interface不是interface,是注解类;在JDK5.0加入的
    ...
} 
```



### @Deprecated

```java
public class Deprecated_ {
    public static void main(String[] args) {
        Test test = new Test();
        System.out.println(test.name);// 依旧可以输出 20
    }
}
/*
  1.@Deprecated 修饰某个元素(类,成员属性,成员方法,字段,参数等等),表示元素已经过时了
  2.即不推荐使用,但是仍然可以使用
  3.@Deprecated 可以做版本升级过度使用 --> JDK8 升级到 JDK11 可以给JDK8中的类添加注解@Deprecated表示该类已经过时,使用JDK11中的新类
*/
@Deprecated
class Test{
    @Deprecated
    int name = 20;
    @Deprecated
    public void test(){};
}
```

  @Deprecated 底层源码

   ```java
   @Documented
       @Retention(RetentionPolicy.RUNTIME)//  注解作用到运行文件
       @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})//可修饰目标
       public @interface Deprecated {
           ...
       }
   ```



### @SupperssWarnings

@SuppressWarnings: 用于抑制警告信息, 可以修饰数据类型, 字段, 方法, 构造器, 局部变量, 模块

```java
@SuppressWarnings({"uncheckd"}) // 抑制 unchecked 警告
public class Main {
    public static void main(String[] args) {
        @SuppressWarnings({"rawtypes"}) // 抑制 rawtypes 警告
        List list = new ArrayList();
        list.add("jack");
        list.add("tom");

        @SuppressWarnings({"unused"}) // 抑制 unused 警告
        int num = 10;
    }

    @SuppressWarnings({"rawtypes", "unchecked", "unused"}) // 抑制 rawtypes, unchecked, unused 警告
    public static void show1() {{}}
    
    @SuppressWarnings({"all"}) // 抑制所有的警告
    public static void show2() {}
}
```

@SuppressWarnings 源码

```java
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE}) // -->可修饰目标为:数据类型, 字段, 方法, 构造器, 局部变量, 模块
@Retention(RetentionPolicy.SOURCE)// 注解作用到源文件
public @interface SuppressWarnings {
    ...
}
```

常见的 @SuppressWarnings

![](https://banne.oss-cn-shanghai.aliyuncs.com/Java/202206170911365.png)

### MetaAnnotation

简介 : JDK的元注解用于修饰其他的注解而存在;

1. @Rentention 表示 Annotation 的作用范围

   1. RetentionPolicy.SOURCE 作用于 source file (注解作用到源文件) 
   2. RetentionPolicy.CLASS 作用于 class file  (注解作用到编译文件) 
   3. RetentionPolicy.RUNTIME 作用于 runtime (注解作用到运行文件) 
2. @Target 表示 Annotation 可以修饰的内容

3. @Doucument 表示 Annotation 在生成 javadoc 文档 时, 会将 Annotation 保留到 javadoc文档上;

4. @Inherited 表示 Annotation 修饰的类被继承时, 子类自动继承 Annotation

