`普通对象`

![image-20240303144131230](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240303144131230.png) 

`数组对象` 

![image-20240303144401308](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240303144401308.png)  

`Mark Word 结构`

![image-20240303144508875](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240303144508875.png) 

# Monitor

简介 : java对象都可关联一个Monitor对象(JVM虚拟机管理),使用synchronized给对象上锁(重量锁)之后,该对象头Mark Word中就被设置指向Monitor对象的指针;

线程进入synchronized块时,会尝试获取对象的内部锁,对象的内部锁被其他线程持有,当前线程进入阻塞状态;当线程执行完synchronized块中代码或遇到其他异常时,会释放对象的内部锁;

`Monitor 结构:`

![image-20240303144844402](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240303144844402.png) 

## Spin Optimization

简介 :  重量级锁竞争时,通过自旋来进行优化;当前线程自旋成功(这时持锁线程已经退出同步块,释放锁),当前线程可以避免阻塞;

`Spin 流程 :`

![image-20240303202446273](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240303202446273.png) 

# Lightweight Lock

简介 : 轻量级锁对于一个对象有个多线程要加锁,但加锁的时间是错开的(没有竞争),可以通过轻量级锁进行优化;

```java
static final Object obj = new Object();
    public static  void m1(){
        synchronized (obj) {
            // 同步块 A
            m2();
        }
    }
    
    public static  void m2(){
        synchronized (obj) {
            // 同步块 B
        }
    }
```

`Lightweight Lock 工作模式 :`

![image-20240303201503225](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240303201503225.png) 

- 创建Lock Record对象,每个线程栈针包含一个锁记录的结构(内部存储锁定对象的Mark Word)
- Lock Record的Object Reference指向锁对象,尝试通过CAS替换Object的Mark Word的值存入锁记录
- CAS替换成功对象头中存储Lock Record 的地址和状态

## Lock Inflated

简介 :  线程尝试添加轻量锁过程中,CAS操作无法成功,线程中出现了竞争;此时进行锁膨胀,轻量级锁变为重量级锁;

`Lock Inflated过程 :`

![image-20240303201846462](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240303201846462.png) 

# Bias Lock

简介 : 轻量级锁没有竞争时,每次重入仍然需要执行CAS操作;

Java6中引入了Bias Lock进行优化,只有第一次使用CAS将Thread ID设置到对象Mark Word头,当前Thread ID为自身Thread ID没有竞争,以后就无需重新CAS;

对象创建时默认开启偏向锁,Mark Word值为 0x05即最后3位为101, thread epoch age都为0;偏向锁默认是延迟的,不会在程序启动时立即生效;

JVM参数 `XX:BiasedLockingStartupDelay=0`

`Lightweight Lock 执行流程 :`

![image-20240303210703399](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240303210703399.png)  

`Bias Lock 执行流程 :`

![image-20240303203220607](https://banne.oss-cn-shanghai.aliyuncs.com/Java/image-20240303203220607.png) 

*撤销偏向锁的情况 :*

1. 调用对象的hashCode,导致偏向锁被撤销(偏向锁对象 Mark Word中存储是线程ID)
2. 其他线程使用偏向锁对象
3. 调用 wait / notify (wait方法释放锁,当前线程被挂起,将不再持有该锁)

## Batch Bias

简介 :  对象被多个线程访问,但没有竞争;偏向线程T1的对象仍有机会重新偏向线程T2,重偏向会重置对象的Thread ID;

当撤销偏向锁阈值超过 20 次后,vm 会这样觉得,我是不是偏向错了呢,于是会在给这些对象加锁时重新偏向至加锁线程;


## Batch Retry

简介 : 当撤销偏向锁阈值超过 40 次后,jvm 会这样觉得,自己确实偏向错了,根本就不该偏向;

于是整个类的所有对象都会变为不可偏向的,新建的对象也是不可偏向的;

# Lock Elimination

简介 : 锁消除是指在编译器级别或即时编译器(Just-In-Time Compiler，JIT)优化过程中,通过静态分析发现某些同步块中不可能存在竞争的情况;

可以安全地省略对这些同步块的锁定操作,从而减少不必要的同步开销;

```java
public class Example {
    public void foo() {
        // 针对局部变量的同步块
        synchronized (this) {
            // 一些操作
        }
    }
}
```

# wait() / notify()

简介 : wait() 与 notify() 用于线程间通信的方法,通常与synchronized关键字一起使用;实现线程之间的协作,允许一个线程等待另一个线程的通知,并在特定条件下唤醒等待的线程;

wait()会释放持有的锁,并进入等待状态,直到其他线程调用相同对象的notify()来唤醒;

notify() 唤醒等待在同一个对象上的某个线程;

```java
public class Example {
    private boolean flag = false;

    public synchronized void waitForFlag() throws InterruptedException {
        while (!flag) {
            wait(); // 等待 flag 变为 true
        }
    }

    public synchronized void setFlag() {
        flag = true;
        notify(); // 唤醒等待的线程
    }
}
```

*sleep(long n) 和 wait(long n) 区别 :*

- sleep是Thread的方法,Object是wait的方法
- sleep不需要强制和Synchronized配合使用,wait需要搭配Synchronized使用
- sleep睡眠的同时不会释放对象锁,wait在等待时会释放对象锁;

# park() / unpark()

简介 : LockSupport类中的方法,用于线程的阻塞和唤醒;

`park()`将当前线程进入等待状态,直到调用`unpark(Thread thread)`方法或者`线程被中断`;

`unpark(Thread thread)`方法在`park()`方法调用之前调用,`park()`方法则不会造成线程阻塞;

```java
import java.util.concurrent.locks.LockSupport;

public class ParkUnparkExample {

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            System.out.println("Thread started");
            // 调用park()方法，线程会被阻塞
            LockSupport.park();
            System.out.println("Thread resumed");
        });

        thread.start();

        // 主线程睡眠1秒钟
        Thread.sleep(1000);

        // 唤醒被阻塞的线程
        LockSupport.unpark(thread);
    }
}

```

